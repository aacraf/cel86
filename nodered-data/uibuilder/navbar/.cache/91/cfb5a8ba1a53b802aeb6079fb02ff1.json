{"id":"../node_modules/bootstrap-vue/esm/utils/router.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"../constants/regex","loc":{"line":1,"column":77,"index":77},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/router.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/regex.js"},{"name":"./dom","loc":{"line":2,"column":22,"index":121},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/router.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/dom.js"},{"name":"./inspect","loc":{"line":3,"column":70,"index":200},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/router.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/inspect.js"},{"name":"./object","loc":{"line":4,"column":21,"index":234},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/router.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/object.js"},{"name":"./string","loc":{"line":5,"column":25,"index":271},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/router.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/string.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringifyQueryObj = exports.parseQuery = exports.isRouterLink = exports.isLink = exports.computeTag = exports.computeRel = exports.computeHref = void 0;\n\nvar _regex = require(\"../constants/regex\");\n\nvar _dom = require(\"./dom\");\n\nvar _inspect = require(\"./inspect\");\n\nvar _object = require(\"./object\");\n\nvar _string = require(\"./string\");\n\nvar ANCHOR_TAG = 'a'; // Method to replace reserved chars\n\nvar encodeReserveReplacer = function encodeReserveReplacer(c) {\n  return '%' + c.charCodeAt(0).toString(16);\n}; // Fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\n\n\nvar encode = function encode(str) {\n  return encodeURIComponent((0, _string.toString)(str)).replace(_regex.RX_ENCODE_REVERSE, encodeReserveReplacer).replace(_regex.RX_ENCODED_COMMA, ',');\n};\n\nvar decode = decodeURIComponent; // Stringifies an object of query parameters\n// See: https://github.com/vuejs/vue-router/blob/dev/src/util/query.js\n\nvar stringifyQueryObj = function stringifyQueryObj(obj) {\n  if (!(0, _inspect.isPlainObject)(obj)) {\n    return '';\n  }\n\n  var query = (0, _object.keys)(obj).map(function (key) {\n    var value = obj[key];\n\n    if ((0, _inspect.isUndefined)(value)) {\n      return '';\n    } else if ((0, _inspect.isNull)(value)) {\n      return encode(key);\n    } else if ((0, _inspect.isArray)(value)) {\n      return value.reduce(function (results, value2) {\n        if ((0, _inspect.isNull)(value2)) {\n          results.push(encode(key));\n        } else if (!(0, _inspect.isUndefined)(value2)) {\n          // Faster than string interpolation\n          results.push(encode(key) + '=' + encode(value2));\n        }\n\n        return results;\n      }, []).join('&');\n    } // Faster than string interpolation\n\n\n    return encode(key) + '=' + encode(value);\n  })\n  /* must check for length, as we only want to filter empty strings, not things that look falsey! */\n  .filter(function (x) {\n    return x.length > 0;\n  }).join('&');\n  return query ? \"?\".concat(query) : '';\n};\n\nexports.stringifyQueryObj = stringifyQueryObj;\n\nvar parseQuery = function parseQuery(query) {\n  var parsed = {};\n  query = (0, _string.toString)(query).trim().replace(_regex.RX_QUERY_START, '');\n\n  if (!query) {\n    return parsed;\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(_regex.RX_PLUS, ' ').split('=');\n    var key = decode(parts.shift());\n    var value = parts.length > 0 ? decode(parts.join('=')) : null;\n\n    if ((0, _inspect.isUndefined)(parsed[key])) {\n      parsed[key] = value;\n    } else if ((0, _inspect.isArray)(parsed[key])) {\n      parsed[key].push(value);\n    } else {\n      parsed[key] = [parsed[key], value];\n    }\n  });\n  return parsed;\n};\n\nexports.parseQuery = parseQuery;\n\nvar isLink = function isLink(props) {\n  return !!(props.href || props.to);\n};\n\nexports.isLink = isLink;\n\nvar isRouterLink = function isRouterLink(tag) {\n  return !!(tag && !(0, _dom.isTag)(tag, 'a'));\n};\n\nexports.isRouterLink = isRouterLink;\n\nvar computeTag = function computeTag(_ref, thisOrParent) {\n  var to = _ref.to,\n      disabled = _ref.disabled,\n      routerComponentName = _ref.routerComponentName;\n  var hasRouter = !!thisOrParent.$router;\n\n  if (!hasRouter || hasRouter && (disabled || !to)) {\n    return ANCHOR_TAG;\n  } // TODO:\n  //   Check registered components for existence of user supplied router link component name\n  //   We would need to check PascalCase, kebab-case, and camelCase versions of name:\n  //   const name = routerComponentName\n  //   const names = [name, PascalCase(name), KebabCase(name), CamelCase(name)]\n  //   exists = names.some(name => !!thisOrParent.$options.components[name])\n  //   And may want to cache the result for performance or we just let the render fail\n  //   if the component is not registered\n\n\n  return routerComponentName || (thisOrParent.$nuxt ? 'nuxt-link' : 'router-link');\n};\n\nexports.computeTag = computeTag;\n\nvar computeRel = function computeRel() {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      target = _ref2.target,\n      rel = _ref2.rel;\n\n  return target === '_blank' && (0, _inspect.isNull)(rel) ? 'noopener' : rel || null;\n};\n\nexports.computeRel = computeRel;\n\nvar computeHref = function computeHref() {\n  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      href = _ref3.href,\n      to = _ref3.to;\n\n  var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ANCHOR_TAG;\n  var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#';\n  var toFallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/'; // Return `href` when explicitly provided\n\n  if (href) {\n    return href;\n  } // We've checked for `$router` in `computeTag()`, so `isRouterLink()` indicates a live router\n  // When deferring to Vue Router's `<router-link>`, don't use the `href` attribute at all\n  // We return `null`, and then remove `href` from the attributes passed to `<router-link>`\n\n\n  if (isRouterLink(tag)) {\n    return null;\n  } // Fallback to `to` prop (if `to` is a string)\n\n\n  if ((0, _inspect.isString)(to)) {\n    return to || toFallback;\n  } // Fallback to `to.path' + `to.query` + `to.hash` prop (if `to` is an object)\n\n\n  if ((0, _inspect.isPlainObject)(to) && (to.path || to.query || to.hash)) {\n    var path = (0, _string.toString)(to.path);\n    var query = stringifyQueryObj(to.query);\n    var hash = (0, _string.toString)(to.hash);\n    hash = !hash || hash.charAt(0) === '#' ? hash : \"#\".concat(hash);\n    return \"\".concat(path).concat(query).concat(hash) || toFallback;\n  } // If nothing is provided return the fallback\n\n\n  return fallback;\n};\n\nexports.computeHref = computeHref;"},"sourceMaps":null,"error":null,"hash":"e362115e0bad82dc253e202c7ca2cfa5","cacheData":{"env":{}}}