{"id":"../node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"../../vue","loc":{"line":23,"column":20,"index":2401},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/vue.js"},{"name":"../../constants/components","loc":{"line":24,"column":31,"index":2445},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/components.js"},{"name":"../../constants/events","loc":{"line":25,"column":92,"index":2567},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/events.js"},{"name":"../../constants/key-codes","loc":{"line":26,"column":56,"index":2649},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/key-codes.js"},{"name":"../../constants/props","loc":{"line":27,"column":180,"index":2858},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/props.js"},{"name":"../../constants/regex","loc":{"line":28,"column":26,"index":2909},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/regex.js"},{"name":"../../constants/slots","loc":{"line":29,"column":61,"index":2995},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/slots.js"},{"name":"../../utils/array","loc":{"line":30,"column":38,"index":3058},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/array.js"},{"name":"../../utils/css-escape","loc":{"line":31,"column":26,"index":3105},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/css-escape.js"},{"name":"../../utils/dom","loc":{"line":32,"column":96,"index":3227},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/dom.js"},{"name":"../../utils/events","loc":{"line":33,"column":45,"index":3291},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/events.js"},{"name":"../../utils/identity","loc":{"line":34,"column":25,"index":3338},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/identity.js"},{"name":"../../utils/inspect","loc":{"line":35,"column":44,"index":3406},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/inspect.js"},{"name":"../../utils/loose-equal","loc":{"line":36,"column":27,"index":3456},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/loose-equal.js"},{"name":"../../utils/model","loc":{"line":37,"column":31,"index":3514},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/model.js"},{"name":"../../utils/object","loc":{"line":38,"column":31,"index":3566},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/object.js"},{"name":"../../utils/props","loc":{"line":39,"column":65,"index":3653},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js"},{"name":"../../utils/string","loc":{"line":40,"column":55,"index":3729},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/string.js"},{"name":"../../mixins/form-control","loc":{"line":41,"column":60,"index":3811},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-control.js"},{"name":"../../mixins/form-size","loc":{"line":42,"column":54,"index":3894},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-size.js"},{"name":"../../mixins/form-state","loc":{"line":43,"column":56,"index":3976},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-state.js"},{"name":"../../mixins/id","loc":{"line":44,"column":42,"index":4045},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/id.js"},{"name":"../../mixins/normalize-slot","loc":{"line":45,"column":35,"index":4099},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/normalize-slot.js"},{"name":"../button/button","loc":{"line":46,"column":24,"index":4154},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/button/button.js"},{"name":"../form/form-invalid-feedback","loc":{"line":47,"column":37,"index":4211},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form/form-invalid-feedback.js"},{"name":"../form/form-text","loc":{"line":48,"column":26,"index":4270},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form/form-text.js"},{"name":"./form-tag","loc":{"line":49,"column":25,"index":4316},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tags.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-tags/form-tag.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BFormTags = void 0;\n\nvar _vue = require(\"../../vue\");\n\nvar _components = require(\"../../constants/components\");\n\nvar _events = require(\"../../constants/events\");\n\nvar _keyCodes = require(\"../../constants/key-codes\");\n\nvar _props = require(\"../../constants/props\");\n\nvar _regex = require(\"../../constants/regex\");\n\nvar _slots = require(\"../../constants/slots\");\n\nvar _array = require(\"../../utils/array\");\n\nvar _cssEscape = require(\"../../utils/css-escape\");\n\nvar _dom = require(\"../../utils/dom\");\n\nvar _events2 = require(\"../../utils/events\");\n\nvar _identity = require(\"../../utils/identity\");\n\nvar _inspect = require(\"../../utils/inspect\");\n\nvar _looseEqual = require(\"../../utils/loose-equal\");\n\nvar _model = require(\"../../utils/model\");\n\nvar _object = require(\"../../utils/object\");\n\nvar _props2 = require(\"../../utils/props\");\n\nvar _string = require(\"../../utils/string\");\n\nvar _formControl = require(\"../../mixins/form-control\");\n\nvar _formSize = require(\"../../mixins/form-size\");\n\nvar _formState = require(\"../../mixins/form-state\");\n\nvar _id = require(\"../../mixins/id\");\n\nvar _normalizeSlot = require(\"../../mixins/normalize-slot\");\n\nvar _button = require(\"../button/button\");\n\nvar _formInvalidFeedback = require(\"../form/form-invalid-feedback\");\n\nvar _formText = require(\"../form/form-text\");\n\nvar _formTag = require(\"./form-tag\");\n\nvar _watch;\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Tagged input form control\n// Based loosely on https://adamwathan.me/renderless-components-in-vuejs/\n\n\n// --- Constants ---\nvar _makeModelMixin = (0, _model.makeModelMixin)('value', {\n  type: _props.PROP_TYPE_ARRAY,\n  defaultValue: []\n}),\n    modelMixin = _makeModelMixin.mixin,\n    modelProps = _makeModelMixin.props,\n    MODEL_PROP_NAME = _makeModelMixin.prop,\n    MODEL_EVENT_NAME = _makeModelMixin.event; // Supported input types (for built in input)\n\n\nvar TYPES = ['text', 'email', 'tel', 'url', 'number']; // Default ignore input focus selector\n\nvar DEFAULT_INPUT_FOCUS_SELECTOR = ['.b-form-tag', 'button', 'input', 'select'].join(' '); // --- Helper methods ---\n// Escape special chars in string and replace\n// contiguous spaces with a whitespace match\n\nvar escapeRegExpChars = function escapeRegExpChars(str) {\n  return (0, _string.escapeRegExp)(str).replace(_regex.RX_SPACES, '\\\\s');\n}; // Remove leading/trailing spaces from array of tags and remove duplicates\n\n\nvar cleanTags = function cleanTags(tags) {\n  return (0, _array.concat)(tags).map(function (tag) {\n    return (0, _string.trim)((0, _string.toString)(tag));\n  }).filter(function (tag, index, arr) {\n    return tag.length > 0 && arr.indexOf(tag) === index;\n  });\n}; // Processes an input/change event, normalizing string or event argument\n\n\nvar processEventValue = function processEventValue(event) {\n  return (0, _inspect.isString)(event) ? event : (0, _inspect.isEvent)(event) ? event.target.value || '' : '';\n}; // Returns a fresh empty `tagsState` object\n\n\nvar cleanTagsState = function cleanTagsState() {\n  return {\n    all: [],\n    valid: [],\n    invalid: [],\n    duplicate: []\n  };\n}; // --- Props ---\n\n\nvar props = (0, _props2.makePropsConfigurable)((0, _object.sortKeys)(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, _id.props), modelProps), _formControl.props), _formSize.props), _formState.props), {}, {\n  addButtonText: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Add'),\n  addButtonVariant: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'outline-secondary'),\n  // Enable change event triggering tag addition\n  // Handy if using <select> as the input\n  addOnChange: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  duplicateTagText: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Duplicate tag(s)'),\n  // Disable the input focus behavior when clicking\n  // on element matching the selector (or selectors)\n  ignoreInputFocusSelector: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_STRING, DEFAULT_INPUT_FOCUS_SELECTOR),\n  // Additional attributes to add to the input element\n  inputAttrs: (0, _props2.makeProp)(_props.PROP_TYPE_OBJECT, {}),\n  inputClass: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_OBJECT_STRING),\n  inputId: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n  inputType: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'text', function (value) {\n    return (0, _array.arrayIncludes)(TYPES, value);\n  }),\n  invalidTagText: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Invalid tag(s)'),\n  limit: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER),\n  limitTagsText: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Tag limit reached'),\n  // Disable ENTER key from triggering tag addition\n  noAddOnEnter: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // Disable the focus ring on the root element\n  noOuterFocus: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  noTagRemove: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  placeholder: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Add tag...'),\n  // Enable deleting last tag in list when CODE_BACKSPACE is\n  // pressed and input is empty\n  removeOnDelete: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // Character (or characters) that trigger adding tags\n  separator: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_STRING),\n  tagClass: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_OBJECT_STRING),\n  tagPills: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  tagRemoveLabel: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Remove tag'),\n  tagRemovedLabel: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Tag removed'),\n  tagValidator: (0, _props2.makeProp)(_props.PROP_TYPE_FUNCTION),\n  tagVariant: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'secondary')\n})), _components.NAME_FORM_TAGS); // --- Main component ---\n// @vue/component\n\nvar BFormTags = /*#__PURE__*/_vue.Vue.extend({\n  name: _components.NAME_FORM_TAGS,\n  mixins: [_id.idMixin, modelMixin, _formControl.formControlMixin, _formSize.formSizeMixin, _formState.formStateMixin, _normalizeSlot.normalizeSlotMixin],\n  props: props,\n  data: function data() {\n    return {\n      hasFocus: false,\n      newTag: '',\n      tags: [],\n      // Tags that were removed\n      removedTags: [],\n      // Populated when tags are parsed\n      tagsState: cleanTagsState()\n    };\n  },\n  computed: {\n    computedInputId: function computedInputId() {\n      return this.inputId || this.safeId('__input__');\n    },\n    computedInputType: function computedInputType() {\n      // We only allow certain types\n      return (0, _array.arrayIncludes)(TYPES, this.inputType) ? this.inputType : 'text';\n    },\n    computedInputAttrs: function computedInputAttrs() {\n      var disabled = this.disabled,\n          form = this.form;\n      return _objectSpread(_objectSpread({}, this.inputAttrs), {}, {\n        // Must have attributes\n        id: this.computedInputId,\n        value: this.newTag,\n        disabled: disabled,\n        form: form\n      });\n    },\n    computedInputHandlers: function computedInputHandlers() {\n      return {\n        input: this.onInputInput,\n        change: this.onInputChange,\n        keydown: this.onInputKeydown,\n        reset: this.reset\n      };\n    },\n    computedSeparator: function computedSeparator() {\n      // Merge the array into a string\n      return (0, _array.concat)(this.separator).filter(_inspect.isString).filter(_identity.identity).join('');\n    },\n    computedSeparatorRegExp: function computedSeparatorRegExp() {\n      // We use a computed prop here to precompile the RegExp\n      // The RegExp is a character class RE in the form of `/[abc]+/`\n      // where a, b, and c are the valid separator characters\n      // -> `tags = str.split(/[abc]+/).filter(t => t)`\n      var separator = this.computedSeparator;\n      return separator ? new RegExp(\"[\".concat(escapeRegExpChars(separator), \"]+\")) : null;\n    },\n    computedJoiner: function computedJoiner() {\n      // When tag(s) are invalid or duplicate, we leave them\n      // in the input so that the user can see them\n      // If there are more than one tag in the input, we use the\n      // first separator character as the separator in the input\n      // We append a space if the first separator is not a space\n      var joiner = this.computedSeparator.charAt(0);\n      return joiner !== ' ' ? \"\".concat(joiner, \" \") : joiner;\n    },\n    computeIgnoreInputFocusSelector: function computeIgnoreInputFocusSelector() {\n      // Normalize to an single selector with selectors separated by `,`\n      return (0, _array.concat)(this.ignoreInputFocusSelector).filter(_identity.identity).join(',').trim();\n    },\n    disableAddButton: function disableAddButton() {\n      var _this = this; // If 'Add' button should be disabled\n      // If the input contains at least one tag that can\n      // be added, then the 'Add' button should be enabled\n\n\n      var newTag = (0, _string.trim)(this.newTag);\n      return newTag === '' || !this.splitTags(newTag).some(function (t) {\n        return !(0, _array.arrayIncludes)(_this.tags, t) && _this.validateTag(t);\n      });\n    },\n    duplicateTags: function duplicateTags() {\n      return this.tagsState.duplicate;\n    },\n    hasDuplicateTags: function hasDuplicateTags() {\n      return this.duplicateTags.length > 0;\n    },\n    invalidTags: function invalidTags() {\n      return this.tagsState.invalid;\n    },\n    hasInvalidTags: function hasInvalidTags() {\n      return this.invalidTags.length > 0;\n    },\n    isLimitReached: function isLimitReached() {\n      var limit = this.limit;\n      return (0, _inspect.isNumber)(limit) && limit >= 0 && this.tags.length >= limit;\n    }\n  },\n  watch: (_watch = {}, _defineProperty(_watch, MODEL_PROP_NAME, function (newValue) {\n    this.tags = cleanTags(newValue);\n  }), _defineProperty(_watch, \"tags\", function tags(newValue, oldValue) {\n    // Update the `v-model` (if it differs from the value prop)\n    if (!(0, _looseEqual.looseEqual)(newValue, this[MODEL_PROP_NAME])) {\n      this.$emit(MODEL_EVENT_NAME, newValue);\n    }\n\n    if (!(0, _looseEqual.looseEqual)(newValue, oldValue)) {\n      newValue = (0, _array.concat)(newValue).filter(_identity.identity);\n      oldValue = (0, _array.concat)(oldValue).filter(_identity.identity);\n      this.removedTags = oldValue.filter(function (old) {\n        return !(0, _array.arrayIncludes)(newValue, old);\n      });\n    }\n  }), _defineProperty(_watch, \"tagsState\", function tagsState(newValue, oldValue) {\n    // Emit a tag-state event when the `tagsState` object changes\n    if (!(0, _looseEqual.looseEqual)(newValue, oldValue)) {\n      this.$emit(_events.EVENT_NAME_TAG_STATE, newValue.valid, newValue.invalid, newValue.duplicate);\n    }\n  }), _watch),\n  created: function created() {\n    // We do this in created to make sure an input event emits\n    // if the cleaned tags are not equal to the value prop\n    this.tags = cleanTags(this[MODEL_PROP_NAME]);\n  },\n  mounted: function mounted() {\n    var _this2 = this; // Listen for form reset events, to reset the tags input\n\n\n    var $form = (0, _dom.closest)('form', this.$el);\n\n    if ($form) {\n      (0, _events2.eventOn)($form, 'reset', this.reset, _events.EVENT_OPTIONS_PASSIVE);\n      this.$on(_events.HOOK_EVENT_NAME_BEFORE_DESTROY, function () {\n        (0, _events2.eventOff)($form, 'reset', _this2.reset, _events.EVENT_OPTIONS_PASSIVE);\n      });\n    }\n  },\n  methods: {\n    addTag: function addTag(newTag) {\n      newTag = (0, _inspect.isString)(newTag) ? newTag : this.newTag;\n      /* istanbul ignore next */\n\n      if (this.disabled || (0, _string.trim)(newTag) === '' || this.isLimitReached) {\n        // Early exit\n        return;\n      }\n\n      var parsed = this.parseTags(newTag); // Add any new tags to the `tags` array, or if the\n      // array of `allTags` is empty, we clear the input\n\n      if (parsed.valid.length > 0 || parsed.all.length === 0) {\n        // Clear the user input element (and leave in any invalid/duplicate tag(s)\n\n        /* istanbul ignore if: full testing to be added later */\n        if ((0, _dom.matches)(this.getInput(), 'select')) {\n          // The following is needed to properly\n          // work with `<select>` elements\n          this.newTag = '';\n        } else {\n          var invalidAndDuplicates = [].concat(_toConsumableArray(parsed.invalid), _toConsumableArray(parsed.duplicate));\n          this.newTag = parsed.all.filter(function (tag) {\n            return (0, _array.arrayIncludes)(invalidAndDuplicates, tag);\n          }).join(this.computedJoiner).concat(invalidAndDuplicates.length > 0 ? this.computedJoiner.charAt(0) : '');\n        }\n      }\n\n      if (parsed.valid.length > 0) {\n        // We add the new tags in one atomic operation\n        // to trigger reactivity once (instead of once per tag)\n        // We do this after we update the new tag input value\n        // `concat()` can be faster than array spread, when both args are arrays\n        this.tags = (0, _array.concat)(this.tags, parsed.valid);\n      }\n\n      this.tagsState = parsed; // Attempt to re-focus the input (specifically for when using the Add\n      // button, as the button disappears after successfully adding a tag\n\n      this.focus();\n    },\n    removeTag: function removeTag(tag) {\n      var _this3 = this;\n      /* istanbul ignore next */\n\n\n      if (this.disabled) {\n        return;\n      } // TODO:\n      //   Add `onRemoveTag(tag)` user method, which if returns `false`\n      //   will prevent the tag from being removed (i.e. confirmation)\n      //   Or emit cancelable `BvEvent`\n\n\n      this.tags = this.tags.filter(function (t) {\n        return t !== tag;\n      }); // Return focus to the input (if possible)\n\n      this.$nextTick(function () {\n        _this3.focus();\n      });\n    },\n    reset: function reset() {\n      var _this4 = this;\n\n      this.newTag = '';\n      this.tags = [];\n      this.$nextTick(function () {\n        _this4.removedTags = [];\n        _this4.tagsState = cleanTagsState();\n      });\n    },\n    // --- Input element event handlers ---\n    onInputInput: function onInputInput(event) {\n      /* istanbul ignore next: hard to test composition events */\n      if (this.disabled || (0, _inspect.isEvent)(event) && event.target.composing) {\n        // `event.target.composing` is set by Vue (`v-model` directive)\n        // https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/directives/model.js\n        return;\n      }\n\n      var newTag = processEventValue(event);\n      var separatorRe = this.computedSeparatorRegExp;\n\n      if (this.newTag !== newTag) {\n        this.newTag = newTag;\n      } // We ignore leading whitespace for the following\n\n\n      newTag = (0, _string.trimLeft)(newTag);\n\n      if (separatorRe && separatorRe.test(newTag.slice(-1))) {\n        // A trailing separator character was entered, so add the tag(s)\n        // Note: More than one tag on input event is possible via copy/paste\n        this.addTag();\n      } else {\n        // Validate (parse tags) on input event\n        this.tagsState = newTag === '' ? cleanTagsState() : this.parseTags(newTag);\n      }\n    },\n    onInputChange: function onInputChange(event) {\n      // Change is triggered on `<input>` blur, or `<select>` selected\n      // This event is opt-in\n      if (!this.disabled && this.addOnChange) {\n        var newTag = processEventValue(event);\n        /* istanbul ignore next */\n\n        if (this.newTag !== newTag) {\n          this.newTag = newTag;\n        }\n\n        this.addTag();\n      }\n    },\n    onInputKeydown: function onInputKeydown(event) {\n      // Early exit\n\n      /* istanbul ignore next */\n      if (this.disabled || !(0, _inspect.isEvent)(event)) {\n        return;\n      }\n\n      var keyCode = event.keyCode;\n      var value = event.target.value || '';\n      /* istanbul ignore else: testing to be added later */\n\n      if (!this.noAddOnEnter && keyCode === _keyCodes.CODE_ENTER) {\n        // Attempt to add the tag when user presses enter\n        (0, _events2.stopEvent)(event, {\n          propagation: false\n        });\n        this.addTag();\n      } else if (this.removeOnDelete && (keyCode === _keyCodes.CODE_BACKSPACE || keyCode === _keyCodes.CODE_DELETE) && value === '') {\n        // Remove the last tag if the user pressed backspace/delete and the input is empty\n        (0, _events2.stopEvent)(event, {\n          propagation: false\n        });\n        this.tags = this.tags.slice(0, -1);\n      }\n    },\n    // --- Wrapper event handlers ---\n    onClick: function onClick(event) {\n      var _this5 = this;\n\n      var ignoreFocusSelector = this.computeIgnoreInputFocusSelector;\n      var target = event.target;\n\n      if (!this.disabled && !(0, _dom.isActiveElement)(target) && (!ignoreFocusSelector || !(0, _dom.closest)(ignoreFocusSelector, target, true))) {\n        this.$nextTick(function () {\n          _this5.focus();\n        });\n      }\n    },\n    onFocusin: function onFocusin() {\n      this.hasFocus = true;\n    },\n    onFocusout: function onFocusout() {\n      this.hasFocus = false;\n    },\n    handleAutofocus: function handleAutofocus() {\n      var _this6 = this;\n\n      this.$nextTick(function () {\n        (0, _dom.requestAF)(function () {\n          if (_this6.autofocus && !_this6.disabled) {\n            _this6.focus();\n          }\n        });\n      });\n    },\n    // --- Public methods ---\n    focus: function focus() {\n      if (!this.disabled) {\n        (0, _dom.attemptFocus)(this.getInput());\n      }\n    },\n    blur: function blur() {\n      if (!this.disabled) {\n        (0, _dom.attemptBlur)(this.getInput());\n      }\n    },\n    // --- Private methods ---\n    splitTags: function splitTags(newTag) {\n      // Split the input into an array of raw tags\n      newTag = (0, _string.toString)(newTag);\n      var separatorRe = this.computedSeparatorRegExp; // Split the tag(s) via the optional separator\n      // Normally only a single tag is provided, but copy/paste\n      // can enter multiple tags in a single operation\n\n      return (separatorRe ? newTag.split(separatorRe) : [newTag]).map(_string.trim).filter(_identity.identity);\n    },\n    parseTags: function parseTags(newTag) {\n      var _this7 = this; // Takes `newTag` value and parses it into `validTags`,\n      // `invalidTags`, and duplicate tags as an object\n      // Split the input into raw tags\n\n\n      var tags = this.splitTags(newTag); // Base results\n\n      var parsed = {\n        all: tags,\n        valid: [],\n        invalid: [],\n        duplicate: []\n      }; // Parse the unique tags\n\n      tags.forEach(function (tag) {\n        if ((0, _array.arrayIncludes)(_this7.tags, tag) || (0, _array.arrayIncludes)(parsed.valid, tag)) {\n          // Unique duplicate tags\n          if (!(0, _array.arrayIncludes)(parsed.duplicate, tag)) {\n            parsed.duplicate.push(tag);\n          }\n        } else if (_this7.validateTag(tag)) {\n          // We only add unique/valid tags\n          parsed.valid.push(tag);\n        } else {\n          // Unique invalid tags\n          if (!(0, _array.arrayIncludes)(parsed.invalid, tag)) {\n            parsed.invalid.push(tag);\n          }\n        }\n      });\n      return parsed;\n    },\n    validateTag: function validateTag(tag) {\n      var tagValidator = this.tagValidator;\n      return (0, _props2.hasPropFunction)(tagValidator) ? tagValidator(tag) : true;\n    },\n    getInput: function getInput() {\n      // Returns the input element reference (or null if not found)\n      // We need to escape `computedInputId` since it can be user-provided\n      return (0, _dom.select)(\"#\".concat((0, _cssEscape.cssEscape)(this.computedInputId)), this.$el);\n    },\n    // Default User Interface render\n    defaultRender: function defaultRender(_ref) {\n      var addButtonText = _ref.addButtonText,\n          addButtonVariant = _ref.addButtonVariant,\n          addTag = _ref.addTag,\n          disableAddButton = _ref.disableAddButton,\n          disabled = _ref.disabled,\n          duplicateTagText = _ref.duplicateTagText,\n          inputAttrs = _ref.inputAttrs,\n          inputClass = _ref.inputClass,\n          inputHandlers = _ref.inputHandlers,\n          inputType = _ref.inputType,\n          invalidTagText = _ref.invalidTagText,\n          isDuplicate = _ref.isDuplicate,\n          isInvalid = _ref.isInvalid,\n          isLimitReached = _ref.isLimitReached,\n          limitTagsText = _ref.limitTagsText,\n          noTagRemove = _ref.noTagRemove,\n          placeholder = _ref.placeholder,\n          removeTag = _ref.removeTag,\n          tagClass = _ref.tagClass,\n          tagPills = _ref.tagPills,\n          tagRemoveLabel = _ref.tagRemoveLabel,\n          tagVariant = _ref.tagVariant,\n          tags = _ref.tags;\n      var h = this.$createElement; // Make the list of tags\n\n      var $tags = tags.map(function (tag) {\n        tag = (0, _string.toString)(tag);\n        return h(_formTag.BFormTag, {\n          class: tagClass,\n          // `BFormTag` will auto generate an ID\n          // so we do not need to set the ID prop\n          props: {\n            disabled: disabled,\n            noRemove: noTagRemove,\n            pill: tagPills,\n            removeLabel: tagRemoveLabel,\n            tag: 'li',\n            title: tag,\n            variant: tagVariant\n          },\n          on: {\n            remove: function remove() {\n              return removeTag(tag);\n            }\n          },\n          key: \"tags_\".concat(tag)\n        }, tag);\n      }); // Feedback IDs if needed\n\n      var invalidFeedbackId = invalidTagText && isInvalid ? this.safeId('__invalid_feedback__') : null;\n      var duplicateFeedbackId = duplicateTagText && isDuplicate ? this.safeId('__duplicate_feedback__') : null;\n      var limitFeedbackId = limitTagsText && isLimitReached ? this.safeId('__limit_feedback__') : null; // Compute the `aria-describedby` attribute value\n\n      var ariaDescribedby = [inputAttrs['aria-describedby'], invalidFeedbackId, duplicateFeedbackId, limitFeedbackId].filter(_identity.identity).join(' '); // Input\n\n      var $input = h('input', {\n        staticClass: 'b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0',\n        class: inputClass,\n        style: {\n          outline: 0,\n          minWidth: '5rem'\n        },\n        attrs: _objectSpread(_objectSpread({}, inputAttrs), {}, {\n          'aria-describedby': ariaDescribedby || null,\n          type: inputType,\n          placeholder: placeholder || null\n        }),\n        domProps: {\n          value: inputAttrs.value\n        },\n        on: inputHandlers,\n        // Directive needed to get `event.target.composing` set (if needed)\n        directives: [{\n          name: 'model',\n          value: inputAttrs.value\n        }],\n        ref: 'input'\n      }); // Add button\n\n      var $button = h(_button.BButton, {\n        staticClass: 'b-form-tags-button py-0',\n        class: {\n          // Only show the button if the tag can be added\n          // We use the `invisible` class instead of not rendering\n          // the button, so that we maintain layout to prevent\n          // the user input from jumping around\n          invisible: disableAddButton\n        },\n        style: {\n          fontSize: '90%'\n        },\n        props: {\n          disabled: disableAddButton || isLimitReached,\n          variant: addButtonVariant\n        },\n        on: {\n          click: function click() {\n            return addTag();\n          }\n        },\n        ref: 'button'\n      }, [this.normalizeSlot(_slots.SLOT_NAME_ADD_BUTTON_TEXT) || addButtonText]); // ID of the tags + input `<ul>` list\n      // Note we could concatenate `inputAttrs.id` with '__tag_list__'\n      // but `inputId` may be `null` until after mount\n      // `safeId()` returns `null`, if no user provided ID,\n      // until after mount when a unique ID is generated\n\n      var tagListId = this.safeId('__tag_list__');\n      var $field = h('li', {\n        staticClass: 'b-from-tags-field flex-grow-1',\n        attrs: {\n          role: 'none',\n          'aria-live': 'off',\n          'aria-controls': tagListId\n        },\n        key: 'tags_field'\n      }, [h('div', {\n        staticClass: 'd-flex',\n        attrs: {\n          role: 'group'\n        }\n      }, [$input, $button])]); // Wrap in an unordered list element (we use a list for accessibility)\n\n      var $ul = h('ul', {\n        staticClass: 'b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center',\n        attrs: {\n          id: tagListId\n        },\n        key: 'tags_list'\n      }, [$tags, $field]); // Assemble the feedback\n\n      var $feedback = h();\n\n      if (invalidTagText || duplicateTagText || limitTagsText) {\n        // Add an aria live region for the invalid/duplicate tag\n        // messages if the user has not disabled the messages\n        var joiner = this.computedJoiner; // Invalid tag feedback if needed (error)\n\n        var $invalid = h();\n\n        if (invalidFeedbackId) {\n          $invalid = h(_formInvalidFeedback.BFormInvalidFeedback, {\n            props: {\n              id: invalidFeedbackId,\n              forceShow: true\n            },\n            key: 'tags_invalid_feedback'\n          }, [this.invalidTagText, ': ', this.invalidTags.join(joiner)]);\n        } // Duplicate tag feedback if needed (warning, not error)\n\n\n        var $duplicate = h();\n\n        if (duplicateFeedbackId) {\n          $duplicate = h(_formText.BFormText, {\n            props: {\n              id: duplicateFeedbackId\n            },\n            key: 'tags_duplicate_feedback'\n          }, [this.duplicateTagText, ': ', this.duplicateTags.join(joiner)]);\n        } // Limit tags feedback if needed (warning, not error)\n\n\n        var $limit = h();\n\n        if (limitFeedbackId) {\n          $limit = h(_formText.BFormText, {\n            props: {\n              id: limitFeedbackId\n            },\n            key: 'tags_limit_feedback'\n          }, [limitTagsText]);\n        }\n\n        $feedback = h('div', {\n          attrs: {\n            'aria-live': 'polite',\n            'aria-atomic': 'true'\n          },\n          key: 'tags_feedback'\n        }, [$invalid, $duplicate, $limit]);\n      } // Return the content\n\n\n      return [$ul, $feedback];\n    }\n  },\n  render: function render(h) {\n    var name = this.name,\n        disabled = this.disabled,\n        required = this.required,\n        form = this.form,\n        tags = this.tags,\n        computedInputId = this.computedInputId,\n        hasFocus = this.hasFocus,\n        noOuterFocus = this.noOuterFocus; // Scoped slot properties\n\n    var scope = _objectSpread({\n      // Array of tags (shallow copy to prevent mutations)\n      tags: tags.slice(),\n      // <input> v-bind:inputAttrs\n      inputAttrs: this.computedInputAttrs,\n      // We don't include this in the attrs, as users may want to override this\n      inputType: this.computedInputType,\n      // <input> v-on:inputHandlers\n      inputHandlers: this.computedInputHandlers,\n      // Methods\n      removeTag: this.removeTag,\n      addTag: this.addTag,\n      reset: this.reset,\n      // <input> :id=\"inputId\"\n      inputId: computedInputId,\n      // Invalid/Duplicate state information\n      isInvalid: this.hasInvalidTags,\n      invalidTags: this.invalidTags.slice(),\n      isDuplicate: this.hasDuplicateTags,\n      duplicateTags: this.duplicateTags.slice(),\n      isLimitReached: this.isLimitReached,\n      // If the 'Add' button should be disabled\n      disableAddButton: this.disableAddButton\n    }, (0, _object.pick)(this.$props, ['addButtonText', 'addButtonVariant', 'disabled', 'duplicateTagText', 'form', 'inputClass', 'invalidTagText', 'limit', 'limitTagsText', 'noTagRemove', 'placeholder', 'required', 'separator', 'size', 'state', 'tagClass', 'tagPills', 'tagRemoveLabel', 'tagVariant'])); // Generate the user interface\n\n\n    var $content = this.normalizeSlot(_slots.SLOT_NAME_DEFAULT, scope) || this.defaultRender(scope); // Generate the `aria-live` region for the current value(s)\n\n    var $output = h('output', {\n      staticClass: 'sr-only',\n      attrs: {\n        id: this.safeId('__selected_tags__'),\n        role: 'status',\n        for: computedInputId,\n        'aria-live': hasFocus ? 'polite' : 'off',\n        'aria-atomic': 'true',\n        'aria-relevant': 'additions text'\n      }\n    }, this.tags.join(', ')); // Removed tag live region\n\n    var $removed = h('div', {\n      staticClass: 'sr-only',\n      attrs: {\n        id: this.safeId('__removed_tags__'),\n        role: 'status',\n        'aria-live': hasFocus ? 'assertive' : 'off',\n        'aria-atomic': 'true'\n      }\n    }, this.removedTags.length > 0 ? \"(\".concat(this.tagRemovedLabel, \") \").concat(this.removedTags.join(', ')) : ''); // Add hidden inputs for form submission\n\n    var $hidden = h();\n\n    if (name && !disabled) {\n      // We add hidden inputs for each tag if a name is provided\n      // When there are currently no tags, a visually hidden input\n      // with empty value is rendered for proper required handling\n      var hasTags = tags.length > 0;\n      $hidden = (hasTags ? tags : ['']).map(function (tag) {\n        return h('input', {\n          class: {\n            'sr-only': !hasTags\n          },\n          attrs: {\n            type: hasTags ? 'hidden' : 'text',\n            value: tag,\n            required: required,\n            name: name,\n            form: form\n          },\n          key: \"tag_input_\".concat(tag)\n        });\n      });\n    } // Return the rendered output\n\n\n    return h('div', {\n      staticClass: 'b-form-tags form-control h-auto',\n      class: [{\n        focus: hasFocus && !noOuterFocus && !disabled,\n        disabled: disabled\n      }, this.sizeFormClass, this.stateClass],\n      attrs: {\n        id: this.safeId(),\n        role: 'group',\n        tabindex: disabled || noOuterFocus ? null : '-1',\n        'aria-describedby': this.safeId('__selected_tags__')\n      },\n      on: {\n        click: this.onClick,\n        focusin: this.onFocusin,\n        focusout: this.onFocusout\n      }\n    }, [$output, $removed, $content, $hidden]);\n  }\n});\n\nexports.BFormTags = BFormTags;"},"sourceMaps":null,"error":null,"hash":"1b3bb061bdde4602d14735389c32fbd9","cacheData":{"env":{}}}