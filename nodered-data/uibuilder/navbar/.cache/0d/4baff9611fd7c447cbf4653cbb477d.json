{"id":"../node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"../../../vue","loc":{"line":19,"column":20,"index":2285},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/vue.js"},{"name":"../../../constants/events","loc":{"line":20,"column":89,"index":2390},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/events.js"},{"name":"../../../constants/props","loc":{"line":21,"column":93,"index":2512},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/props.js"},{"name":"../../../constants/slots","loc":{"line":22,"column":38,"index":2578},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/slots.js"},{"name":"../../../utils/get","loc":{"line":23,"column":20,"index":2626},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/get.js"},{"name":"../../../utils/inspect","loc":{"line":24,"column":56,"index":2704},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/inspect.js"},{"name":"../../../utils/props","loc":{"line":25,"column":25,"index":2755},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js"},{"name":"../../../utils/string","loc":{"line":26,"column":25,"index":2804},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/string.js"},{"name":"../tr","loc":{"line":27,"column":20,"index":2849},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/tr.js"},{"name":"../td","loc":{"line":28,"column":20,"index":2878},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/td.js"},{"name":"../th","loc":{"line":29,"column":20,"index":2907},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/th.js"},{"name":"./constants","loc":{"line":30,"column":86,"index":3002},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/constants.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tbodyRowMixin = exports.props = void 0;\n\nvar _vue = require(\"../../../vue\");\n\nvar _events = require(\"../../../constants/events\");\n\nvar _props = require(\"../../../constants/props\");\n\nvar _slots = require(\"../../../constants/slots\");\n\nvar _get = require(\"../../../utils/get\");\n\nvar _inspect = require(\"../../../utils/inspect\");\n\nvar _props2 = require(\"../../../utils/props\");\n\nvar _string = require(\"../../../utils/string\");\n\nvar _tr = require(\"../tr\");\n\nvar _td = require(\"../td\");\n\nvar _th = require(\"../th\");\n\nvar _constants = require(\"./constants\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\n// --- Props ---\nvar props = {\n  detailsTdClass: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_OBJECT_STRING),\n  tbodyTrAttr: (0, _props2.makeProp)(_props.PROP_TYPE_OBJECT_FUNCTION),\n  tbodyTrClass: (0, _props2.makeProp)([].concat(_toConsumableArray(_props.PROP_TYPE_ARRAY_OBJECT_STRING), [_props.PROP_TYPE_FUNCTION]))\n}; // --- Mixin ---\n// @vue/component\n\nexports.props = props;\n\nvar tbodyRowMixin = _vue.Vue.extend({\n  props: props,\n  methods: {\n    // Methods for computing classes, attributes and styles for table cells\n    getTdValues: function getTdValues(item, key, tdValue, defaultValue) {\n      var $parent = this.$parent;\n\n      if (tdValue) {\n        var value = (0, _get.get)(item, key, '');\n\n        if ((0, _inspect.isFunction)(tdValue)) {\n          return tdValue(value, key, item);\n        } else if ((0, _inspect.isString)(tdValue) && (0, _inspect.isFunction)($parent[tdValue])) {\n          return $parent[tdValue](value, key, item);\n        }\n\n        return tdValue;\n      }\n\n      return defaultValue;\n    },\n    getThValues: function getThValues(item, key, thValue, type, defaultValue) {\n      var $parent = this.$parent;\n\n      if (thValue) {\n        var value = (0, _get.get)(item, key, '');\n\n        if ((0, _inspect.isFunction)(thValue)) {\n          return thValue(value, key, item, type);\n        } else if ((0, _inspect.isString)(thValue) && (0, _inspect.isFunction)($parent[thValue])) {\n          return $parent[thValue](value, key, item, type);\n        }\n\n        return thValue;\n      }\n\n      return defaultValue;\n    },\n    // Method to get the value for a field\n    getFormattedValue: function getFormattedValue(item, field) {\n      var key = field.key;\n      var formatter = this.getFieldFormatter(key);\n      var value = (0, _get.get)(item, key, null);\n\n      if ((0, _inspect.isFunction)(formatter)) {\n        value = formatter(value, key, item);\n      }\n\n      return (0, _inspect.isUndefinedOrNull)(value) ? '' : value;\n    },\n    // Factory function methods\n    toggleDetailsFactory: function toggleDetailsFactory(hasDetailsSlot, item) {\n      var _this = this; // Returns a function to toggle a row's details slot\n\n\n      return function () {\n        if (hasDetailsSlot) {\n          _this.$set(item, _constants.FIELD_KEY_SHOW_DETAILS, !item[_constants.FIELD_KEY_SHOW_DETAILS]);\n        }\n      };\n    },\n    // Row event handlers\n    rowHovered: function rowHovered(event) {\n      // `mouseenter` handler (non-bubbling)\n      // `this.tbodyRowEvtStopped` from tbody mixin\n      if (!this.tbodyRowEvtStopped(event)) {\n        // `this.emitTbodyRowEvent` from tbody mixin\n        this.emitTbodyRowEvent(_events.EVENT_NAME_ROW_HOVERED, event);\n      }\n    },\n    rowUnhovered: function rowUnhovered(event) {\n      // `mouseleave` handler (non-bubbling)\n      // `this.tbodyRowEvtStopped` from tbody mixin\n      if (!this.tbodyRowEvtStopped(event)) {\n        // `this.emitTbodyRowEvent` from tbody mixin\n        this.emitTbodyRowEvent(_events.EVENT_NAME_ROW_UNHOVERED, event);\n      }\n    },\n    // Renders a TD or TH for a row's field\n    renderTbodyRowCell: function renderTbodyRowCell(field, colIndex, item, rowIndex) {\n      var _this2 = this;\n\n      var isStacked = this.isStacked;\n      var key = field.key,\n          label = field.label,\n          isRowHeader = field.isRowHeader;\n      var h = this.$createElement;\n      var hasDetailsSlot = this.hasNormalizedSlot(_slots.SLOT_NAME_ROW_DETAILS);\n      var formatted = this.getFormattedValue(item, field);\n      var stickyColumn = !isStacked && (this.isResponsive || this.stickyHeader) && field.stickyColumn; // We only uses the helper components for sticky columns to\n      // improve performance of BTable/BTableLite by reducing the\n      // total number of vue instances created during render\n\n      var cellTag = stickyColumn ? isRowHeader ? _th.BTh : _td.BTd : isRowHeader ? 'th' : 'td';\n      var cellVariant = item[_constants.FIELD_KEY_CELL_VARIANT] && item[_constants.FIELD_KEY_CELL_VARIANT][key] ? item[_constants.FIELD_KEY_CELL_VARIANT][key] : field.variant || null;\n      var data = {\n        // For the Vue key, we concatenate the column index and\n        // field key (as field keys could be duplicated)\n        // TODO: Although we do prevent duplicate field keys...\n        //   So we could change this to: `row-${rowIndex}-cell-${key}`\n        class: [field.class ? field.class : '', this.getTdValues(item, key, field.tdClass, '')],\n        props: {},\n        attrs: _objectSpread({\n          'aria-colindex': String(colIndex + 1)\n        }, isRowHeader ? this.getThValues(item, key, field.thAttr, 'row', {}) : this.getTdValues(item, key, field.tdAttr, {})),\n        key: \"row-\".concat(rowIndex, \"-cell-\").concat(colIndex, \"-\").concat(key)\n      };\n\n      if (stickyColumn) {\n        // We are using the helper BTd or BTh\n        data.props = {\n          stackedHeading: isStacked ? label : null,\n          stickyColumn: true,\n          variant: cellVariant\n        };\n      } else {\n        // Using native TD or TH element, so we need to\n        // add in the attributes and variant class\n        data.attrs['data-label'] = isStacked && !(0, _inspect.isUndefinedOrNull)(label) ? (0, _string.toString)(label) : null;\n        data.attrs.role = isRowHeader ? 'rowheader' : 'cell';\n        data.attrs.scope = isRowHeader ? 'row' : null; // Add in the variant class\n\n        if (cellVariant) {\n          data.class.push(\"\".concat(this.dark ? 'bg' : 'table', \"-\").concat(cellVariant));\n        }\n      }\n\n      var slotScope = {\n        item: item,\n        index: rowIndex,\n        field: field,\n        unformatted: (0, _get.get)(item, key, ''),\n        value: formatted,\n        toggleDetails: this.toggleDetailsFactory(hasDetailsSlot, item),\n        detailsShowing: Boolean(item[_constants.FIELD_KEY_SHOW_DETAILS])\n      }; // If table supports selectable mode, then add in the following scope\n      // this.supportsSelectableRows will be undefined if mixin isn't loaded\n\n      if (this.supportsSelectableRows) {\n        slotScope.rowSelected = this.isRowSelected(rowIndex);\n\n        slotScope.selectRow = function () {\n          return _this2.selectRow(rowIndex);\n        };\n\n        slotScope.unselectRow = function () {\n          return _this2.unselectRow(rowIndex);\n        };\n      } // The new `v-slot` syntax doesn't like a slot name starting with\n      // a square bracket and if using in-document HTML templates, the\n      // v-slot attributes are lower-cased by the browser.\n      // Switched to round bracket syntax to prevent confusion with\n      // dynamic slot name syntax.\n      // We look for slots in this order: `cell(${key})`, `cell(${key.toLowerCase()})`, 'cell()'\n      // Slot names are now cached by mixin tbody in `this.$_bodyFieldSlotNameCache`\n      // Will be `null` if no slot (or fallback slot) exists\n\n\n      var slotName = this.$_bodyFieldSlotNameCache[key];\n      var $childNodes = slotName ? this.normalizeSlot(slotName, slotScope) : (0, _string.toString)(formatted);\n\n      if (this.isStacked) {\n        // We wrap in a DIV to ensure rendered as a single cell when visually stacked!\n        $childNodes = [h('div', [$childNodes])];\n      } // Render either a td or th cell\n\n\n      return h(cellTag, data, [$childNodes]);\n    },\n    // Renders an item's row (or rows if details supported)\n    renderTbodyRow: function renderTbodyRow(item, rowIndex) {\n      var _this3 = this;\n\n      var fields = this.computedFields,\n          striped = this.striped,\n          primaryKey = this.primaryKey,\n          currentPage = this.currentPage,\n          perPage = this.perPage,\n          tbodyTrClass = this.tbodyTrClass,\n          tbodyTrAttr = this.tbodyTrAttr;\n      var h = this.$createElement;\n      var hasDetailsSlot = this.hasNormalizedSlot(_slots.SLOT_NAME_ROW_DETAILS);\n      var rowShowDetails = item[_constants.FIELD_KEY_SHOW_DETAILS] && hasDetailsSlot;\n      var hasRowClickHandler = this.$listeners[_events.EVENT_NAME_ROW_CLICKED] || this.hasSelectableRowClick; // We can return more than one TR if rowDetails enabled\n\n      var $rows = []; // Details ID needed for `aria-details` when details showing\n      // We set it to `null` when not showing so that attribute\n      // does not appear on the element\n\n      var detailsId = rowShowDetails ? this.safeId(\"_details_\".concat(rowIndex, \"_\")) : null; // For each item data field in row\n\n      var $tds = fields.map(function (field, colIndex) {\n        return _this3.renderTbodyRowCell(field, colIndex, item, rowIndex);\n      }); // Calculate the row number in the dataset (indexed from 1)\n\n      var ariaRowIndex = null;\n\n      if (currentPage && perPage && perPage > 0) {\n        ariaRowIndex = String((currentPage - 1) * perPage + rowIndex + 1);\n      } // Create a unique :key to help ensure that sub components are re-rendered rather than\n      // re-used, which can cause issues. If a primary key is not provided we use the rendered\n      // rows index within the tbody.\n      // See: https://github.com/bootstrap-vue/bootstrap-vue/issues/2410\n\n\n      var primaryKeyValue = (0, _string.toString)((0, _get.get)(item, primaryKey)) || null;\n      var rowKey = primaryKeyValue || (0, _string.toString)(rowIndex); // If primary key is provided, use it to generate a unique ID on each tbody > tr\n      // In the format of '{tableId}__row_{primaryKeyValue}'\n\n      var rowId = primaryKeyValue ? this.safeId(\"_row_\".concat(primaryKeyValue)) : null; // Selectable classes and attributes\n\n      var selectableClasses = this.selectableRowClasses ? this.selectableRowClasses(rowIndex) : {};\n      var selectableAttrs = this.selectableRowAttrs ? this.selectableRowAttrs(rowIndex) : {}; // Additional classes and attributes\n\n      var userTrClasses = (0, _inspect.isFunction)(tbodyTrClass) ? tbodyTrClass(item, 'row') : tbodyTrClass;\n      var userTrAttrs = (0, _inspect.isFunction)(tbodyTrAttr) ?\n      /* istanbul ignore next */\n      tbodyTrAttr(item, 'row') : tbodyTrAttr; // Add the item row\n\n      $rows.push(h(_tr.BTr, {\n        class: [userTrClasses, selectableClasses, rowShowDetails ? 'b-table-has-details' : ''],\n        props: {\n          variant: item[_constants.FIELD_KEY_ROW_VARIANT] || null\n        },\n        attrs: _objectSpread(_objectSpread({\n          id: rowId\n        }, userTrAttrs), {}, {\n          // Users cannot override the following attributes\n          tabindex: hasRowClickHandler ? '0' : null,\n          'data-pk': primaryKeyValue || null,\n          'aria-details': detailsId,\n          'aria-owns': detailsId,\n          'aria-rowindex': ariaRowIndex\n        }, selectableAttrs),\n        on: {\n          // Note: These events are not A11Y friendly!\n          mouseenter: this.rowHovered,\n          mouseleave: this.rowUnhovered\n        },\n        key: \"__b-table-row-\".concat(rowKey, \"__\"),\n        ref: 'item-rows',\n        refInFor: true\n      }, $tds)); // Row Details slot\n\n      if (rowShowDetails) {\n        var detailsScope = {\n          item: item,\n          index: rowIndex,\n          fields: fields,\n          toggleDetails: this.toggleDetailsFactory(hasDetailsSlot, item)\n        }; // If table supports selectable mode, then add in the following scope\n        // this.supportsSelectableRows will be undefined if mixin isn't loaded\n\n        if (this.supportsSelectableRows) {\n          detailsScope.rowSelected = this.isRowSelected(rowIndex);\n\n          detailsScope.selectRow = function () {\n            return _this3.selectRow(rowIndex);\n          };\n\n          detailsScope.unselectRow = function () {\n            return _this3.unselectRow(rowIndex);\n          };\n        } // Render the details slot in a TD\n\n\n        var $details = h(_td.BTd, {\n          props: {\n            colspan: fields.length\n          },\n          class: this.detailsTdClass\n        }, [this.normalizeSlot(_slots.SLOT_NAME_ROW_DETAILS, detailsScope)]); // Add a hidden row to keep table row striping consistent when details showing\n        // Only added if the table is striped\n\n        if (striped) {\n          $rows.push( // We don't use `BTr` here as we don't need the extra functionality\n          h('tr', {\n            staticClass: 'd-none',\n            attrs: {\n              'aria-hidden': 'true',\n              role: 'presentation'\n            },\n            key: \"__b-table-details-stripe__\".concat(rowKey)\n          }));\n        } // Add the actual details row\n\n\n        var userDetailsTrClasses = (0, _inspect.isFunction)(this.tbodyTrClass) ?\n        /* istanbul ignore next */\n        this.tbodyTrClass(item, _slots.SLOT_NAME_ROW_DETAILS) : this.tbodyTrClass;\n        var userDetailsTrAttrs = (0, _inspect.isFunction)(this.tbodyTrAttr) ?\n        /* istanbul ignore next */\n        this.tbodyTrAttr(item, _slots.SLOT_NAME_ROW_DETAILS) : this.tbodyTrAttr;\n        $rows.push(h(_tr.BTr, {\n          staticClass: 'b-table-details',\n          class: [userDetailsTrClasses],\n          props: {\n            variant: item[_constants.FIELD_KEY_ROW_VARIANT] || null\n          },\n          attrs: _objectSpread(_objectSpread({}, userDetailsTrAttrs), {}, {\n            // Users cannot override the following attributes\n            id: detailsId,\n            tabindex: '-1'\n          }),\n          key: \"__b-table-details__\".concat(rowKey)\n        }, [$details]));\n      } else if (hasDetailsSlot) {\n        // Only add the placeholder if a the table has a row-details slot defined (but not shown)\n        $rows.push(h());\n\n        if (striped) {\n          // Add extra placeholder if table is striped\n          $rows.push(h());\n        }\n      } // Return the row(s)\n\n\n      return $rows;\n    }\n  }\n});\n\nexports.tbodyRowMixin = tbodyRowMixin;"},"sourceMaps":null,"error":null,"hash":"65d8c57470f7f758f750db70f48997a0","cacheData":{"env":{}}}