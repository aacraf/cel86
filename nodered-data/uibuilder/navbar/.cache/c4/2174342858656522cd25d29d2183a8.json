{"id":"../node_modules/bootstrap-vue/esm/directives/popover/popover.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"../../constants/components","loc":{"line":7,"column":29,"index":1119},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/popover/popover.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/components.js"},{"name":"../../constants/env","loc":{"line":8,"column":27,"index":1176},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/popover/popover.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/env.js"},{"name":"../../constants/events","loc":{"line":9,"column":32,"index":1231},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/popover/popover.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/events.js"},{"name":"../../utils/array","loc":{"line":10,"column":23,"index":1280},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/popover/popover.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/array.js"},{"name":"../../utils/config","loc":{"line":11,"column":35,"index":1336},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/popover/popover.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/config.js"},{"name":"../../utils/get-scope-id","loc":{"line":12,"column":27,"index":1385},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/popover/popover.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/get-scope-id.js"},{"name":"../../utils/identity","loc":{"line":13,"column":25,"index":1438},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/popover/popover.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/identity.js"},{"name":"../../utils/inspect","loc":{"line":14,"column":94,"index":1556},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/popover/popover.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/inspect.js"},{"name":"../../utils/loose-equal","loc":{"line":15,"column":27,"index":1606},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/popover/popover.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/loose-equal.js"},{"name":"../../utils/number","loc":{"line":16,"column":26,"index":1659},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/popover/popover.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/number.js"},{"name":"../../utils/object","loc":{"line":17,"column":21,"index":1702},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/popover/popover.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/object.js"},{"name":"../../components/popover/helpers/bv-popover","loc":{"line":18,"column":26,"index":1750},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/popover/popover.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/popover/helpers/bv-popover.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VBPopover = void 0;\n\nvar _components = require(\"../../constants/components\");\n\nvar _env = require(\"../../constants/env\");\n\nvar _events = require(\"../../constants/events\");\n\nvar _array = require(\"../../utils/array\");\n\nvar _config = require(\"../../utils/config\");\n\nvar _getScopeId = require(\"../../utils/get-scope-id\");\n\nvar _identity = require(\"../../utils/identity\");\n\nvar _inspect = require(\"../../utils/inspect\");\n\nvar _looseEqual = require(\"../../utils/loose-equal\");\n\nvar _number = require(\"../../utils/number\");\n\nvar _object = require(\"../../utils/object\");\n\nvar _bvPopover = require(\"../../components/popover/helpers/bv-popover\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n// Key which we use to store tooltip object on element\nvar BV_POPOVER = '__BV_Popover__'; // Default trigger\n\nvar DefaultTrigger = 'click'; // Valid event triggers\n\nvar validTriggers = {\n  focus: true,\n  hover: true,\n  click: true,\n  blur: true,\n  manual: true\n}; // Directive modifier test regular expressions. Pre-compile for performance\n\nvar htmlRE = /^html$/i;\nvar noFadeRE = /^nofade$/i;\nvar placementRE = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;\nvar boundaryRE = /^(window|viewport|scrollParent)$/i;\nvar delayRE = /^d\\d+$/i;\nvar delayShowRE = /^ds\\d+$/i;\nvar delayHideRE = /^dh\\d+$/i;\nvar offsetRE = /^o-?\\d+$/i;\nvar variantRE = /^v-.+$/i;\nvar spacesRE = /\\s+/; // Build a Popover config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\n\nvar parseBindings = function parseBindings(bindings, vnode)\n/* istanbul ignore next: not easy to test */\n{\n  // We start out with a basic config\n  var config = {\n    title: undefined,\n    content: undefined,\n    trigger: '',\n    // Default set below if needed\n    placement: 'right',\n    fallbackPlacement: 'flip',\n    container: false,\n    // Default of body\n    animation: true,\n    offset: 0,\n    disabled: false,\n    id: null,\n    html: false,\n    delay: (0, _config.getComponentConfig)(_components.NAME_POPOVER, 'delay', 50),\n    boundary: String((0, _config.getComponentConfig)(_components.NAME_POPOVER, 'boundary', 'scrollParent')),\n    boundaryPadding: (0, _number.toInteger)((0, _config.getComponentConfig)(_components.NAME_POPOVER, 'boundaryPadding', 5), 0),\n    variant: (0, _config.getComponentConfig)(_components.NAME_POPOVER, 'variant'),\n    customClass: (0, _config.getComponentConfig)(_components.NAME_POPOVER, 'customClass')\n  }; // Process `bindings.value`\n\n  if ((0, _inspect.isString)(bindings.value) || (0, _inspect.isNumber)(bindings.value)) {\n    // Value is popover content (html optionally supported)\n    config.content = bindings.value;\n  } else if ((0, _inspect.isFunction)(bindings.value)) {\n    // Content generator function\n    config.content = bindings.value;\n  } else if ((0, _inspect.isPlainObject)(bindings.value)) {\n    // Value is config object, so merge\n    config = _objectSpread(_objectSpread({}, config), bindings.value);\n  } // If argument, assume element ID of container element\n\n\n  if (bindings.arg) {\n    // Element ID specified as arg\n    // We must prepend '#' to become a CSS selector\n    config.container = \"#\".concat(bindings.arg);\n  } // If title is not provided, try title attribute\n\n\n  if ((0, _inspect.isUndefined)(config.title)) {\n    // Try attribute\n    var data = vnode.data || {};\n    config.title = data.attrs && !(0, _inspect.isUndefinedOrNull)(data.attrs.title) ? data.attrs.title : undefined;\n  } // Normalize delay\n\n\n  if (!(0, _inspect.isPlainObject)(config.delay)) {\n    config.delay = {\n      show: (0, _number.toInteger)(config.delay, 0),\n      hide: (0, _number.toInteger)(config.delay, 0)\n    };\n  } // Process modifiers\n\n\n  (0, _object.keys)(bindings.modifiers).forEach(function (mod) {\n    if (htmlRE.test(mod)) {\n      // Title/content allows HTML\n      config.html = true;\n    } else if (noFadeRE.test(mod)) {\n      // No animation\n      config.animation = false;\n    } else if (placementRE.test(mod)) {\n      // Placement of popover\n      config.placement = mod;\n    } else if (boundaryRE.test(mod)) {\n      // Boundary of popover\n      mod = mod === 'scrollparent' ? 'scrollParent' : mod;\n      config.boundary = mod;\n    } else if (delayRE.test(mod)) {\n      // Delay value\n      var delay = (0, _number.toInteger)(mod.slice(1), 0);\n      config.delay.show = delay;\n      config.delay.hide = delay;\n    } else if (delayShowRE.test(mod)) {\n      // Delay show value\n      config.delay.show = (0, _number.toInteger)(mod.slice(2), 0);\n    } else if (delayHideRE.test(mod)) {\n      // Delay hide value\n      config.delay.hide = (0, _number.toInteger)(mod.slice(2), 0);\n    } else if (offsetRE.test(mod)) {\n      // Offset value, negative allowed\n      config.offset = (0, _number.toInteger)(mod.slice(1), 0);\n    } else if (variantRE.test(mod)) {\n      // Variant\n      config.variant = mod.slice(2) || null;\n    }\n  }); // Special handling of event trigger modifiers trigger is\n  // a space separated list\n\n  var selectedTriggers = {}; // Parse current config object trigger\n\n  (0, _array.concat)(config.trigger || '').filter(_identity.identity).join(' ').trim().toLowerCase().split(spacesRE).forEach(function (trigger) {\n    if (validTriggers[trigger]) {\n      selectedTriggers[trigger] = true;\n    }\n  }); // Parse modifiers for triggers\n\n  (0, _object.keys)(bindings.modifiers).forEach(function (mod) {\n    mod = mod.toLowerCase();\n\n    if (validTriggers[mod]) {\n      // If modifier is a valid trigger\n      selectedTriggers[mod] = true;\n    }\n  }); // Sanitize triggers\n\n  config.trigger = (0, _object.keys)(selectedTriggers).join(' ');\n\n  if (config.trigger === 'blur') {\n    // Blur by itself is useless, so convert it to 'focus'\n    config.trigger = 'focus';\n  }\n\n  if (!config.trigger) {\n    // Use default trigger\n    config.trigger = DefaultTrigger;\n  }\n\n  return config;\n}; // Add or update Popover on our element\n\n\nvar applyPopover = function applyPopover(el, bindings, vnode) {\n  if (!_env.IS_BROWSER) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  var config = parseBindings(bindings, vnode);\n\n  if (!el[BV_POPOVER]) {\n    var $parent = vnode.context;\n    el[BV_POPOVER] = new _bvPopover.BVPopover({\n      parent: $parent,\n      // Add the parent's scoped style attribute data\n      _scopeId: (0, _getScopeId.getScopeId)($parent, undefined)\n    });\n    el[BV_POPOVER].__bv_prev_data__ = {};\n    el[BV_POPOVER].$on(_events.EVENT_NAME_SHOW, function ()\n    /* istanbul ignore next: for now */\n    {\n      // Before showing the popover, we update the title\n      // and content if they are functions\n      var data = {};\n\n      if ((0, _inspect.isFunction)(config.title)) {\n        data.title = config.title(el);\n      }\n\n      if ((0, _inspect.isFunction)(config.content)) {\n        data.content = config.content(el);\n      }\n\n      if ((0, _object.keys)(data).length > 0) {\n        el[BV_POPOVER].updateData(data);\n      }\n    });\n  }\n\n  var data = {\n    title: config.title,\n    content: config.content,\n    triggers: config.trigger,\n    placement: config.placement,\n    fallbackPlacement: config.fallbackPlacement,\n    variant: config.variant,\n    customClass: config.customClass,\n    container: config.container,\n    boundary: config.boundary,\n    delay: config.delay,\n    offset: config.offset,\n    noFade: !config.animation,\n    id: config.id,\n    disabled: config.disabled,\n    html: config.html\n  };\n  var oldData = el[BV_POPOVER].__bv_prev_data__;\n  el[BV_POPOVER].__bv_prev_data__ = data;\n\n  if (!(0, _looseEqual.looseEqual)(data, oldData)) {\n    // We only update the instance if data has changed\n    var newData = {\n      target: el\n    };\n    (0, _object.keys)(data).forEach(function (prop) {\n      // We only pass data properties that have changed\n      if (data[prop] !== oldData[prop]) {\n        // If title/content is a function, we execute it here\n        newData[prop] = (prop === 'title' || prop === 'content') && (0, _inspect.isFunction)(data[prop]) ?\n        /* istanbul ignore next */\n        data[prop](el) : data[prop];\n      }\n    });\n    el[BV_POPOVER].updateData(newData);\n  }\n}; // Remove Popover from our element\n\n\nvar removePopover = function removePopover(el) {\n  if (el[BV_POPOVER]) {\n    el[BV_POPOVER].$destroy();\n    el[BV_POPOVER] = null;\n  }\n\n  delete el[BV_POPOVER];\n}; // Export our directive\n\n\nvar VBPopover = {\n  bind: function bind(el, bindings, vnode) {\n    applyPopover(el, bindings, vnode);\n  },\n  // We use `componentUpdated` here instead of `update`, as the former\n  // waits until the containing component and children have finished updating\n  componentUpdated: function componentUpdated(el, bindings, vnode) {\n    // Performed in a `$nextTick()` to prevent endless render/update loops\n    vnode.context.$nextTick(function () {\n      applyPopover(el, bindings, vnode);\n    });\n  },\n  unbind: function unbind(el) {\n    removePopover(el);\n  }\n};\nexports.VBPopover = VBPopover;"},"sourceMaps":null,"error":null,"hash":"9f3e8be9ee20f8785482365df3e5b5b7","cacheData":{"env":{}}}