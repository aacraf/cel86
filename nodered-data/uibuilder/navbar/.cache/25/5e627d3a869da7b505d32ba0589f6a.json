{"id":"../node_modules/bootstrap-vue/esm/components/form-group/form-group.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"../../constants/components","loc":{"line":7,"column":32,"index":1122},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/components.js"},{"name":"../../constants/env","loc":{"line":8,"column":27,"index":1179},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/env.js"},{"name":"../../constants/props","loc":{"line":9,"column":116,"index":1318},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/props.js"},{"name":"../../constants/regex","loc":{"line":10,"column":31,"index":1374},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/regex.js"},{"name":"../../constants/slots","loc":{"line":11,"column":128,"index":1527},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/slots.js"},{"name":"../../utils/array","loc":{"line":12,"column":30,"index":1582},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/array.js"},{"name":"../../utils/config","loc":{"line":13,"column":39,"index":1642},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/config.js"},{"name":"../../utils/css-escape","loc":{"line":14,"column":26,"index":1690},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/css-escape.js"},{"name":"../../utils/dom","loc":{"line":15,"column":89,"index":1805},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/dom.js"},{"name":"../../utils/identity","loc":{"line":16,"column":25,"index":1849},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/identity.js"},{"name":"../../utils/inspect","loc":{"line":17,"column":26,"index":1899},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/inspect.js"},{"name":"../../utils/number","loc":{"line":18,"column":26,"index":1948},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/number.js"},{"name":"../../utils/object","loc":{"line":19,"column":39,"index":2009},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/object.js"},{"name":"../../utils/props","loc":{"line":20,"column":64,"index":2095},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js"},{"name":"../../mixins/form-state","loc":{"line":21,"column":56,"index":2172},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-state.js"},{"name":"../../mixins/id","loc":{"line":22,"column":42,"index":2241},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/id.js"},{"name":"../../mixins/normalize-slot","loc":{"line":23,"column":35,"index":2295},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/normalize-slot.js"},{"name":"../layout/col","loc":{"line":24,"column":21,"index":2347},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/layout/col.js"},{"name":"../layout/form-row","loc":{"line":25,"column":25,"index":2389},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/layout/form-row.js"},{"name":"../form/form-text","loc":{"line":26,"column":26,"index":2437},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form/form-text.js"},{"name":"../form/form-invalid-feedback","loc":{"line":27,"column":37,"index":2495},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form/form-invalid-feedback.js"},{"name":"../form/form-valid-feedback","loc":{"line":28,"column":35,"index":2563},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-group/form-group.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form/form-valid-feedback.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateProps = exports.BFormGroup = void 0;\n\nvar _components = require(\"../../constants/components\");\n\nvar _env = require(\"../../constants/env\");\n\nvar _props = require(\"../../constants/props\");\n\nvar _regex = require(\"../../constants/regex\");\n\nvar _slots = require(\"../../constants/slots\");\n\nvar _array = require(\"../../utils/array\");\n\nvar _config = require(\"../../utils/config\");\n\nvar _cssEscape = require(\"../../utils/css-escape\");\n\nvar _dom = require(\"../../utils/dom\");\n\nvar _identity = require(\"../../utils/identity\");\n\nvar _inspect = require(\"../../utils/inspect\");\n\nvar _number = require(\"../../utils/number\");\n\nvar _object = require(\"../../utils/object\");\n\nvar _props2 = require(\"../../utils/props\");\n\nvar _formState = require(\"../../mixins/form-state\");\n\nvar _id = require(\"../../mixins/id\");\n\nvar _normalizeSlot = require(\"../../mixins/normalize-slot\");\n\nvar _col = require(\"../layout/col\");\n\nvar _formRow = require(\"../layout/form-row\");\n\nvar _formText = require(\"../form/form-text\");\n\nvar _formInvalidFeedback = require(\"../form/form-invalid-feedback\");\n\nvar _formValidFeedback = require(\"../form/form-valid-feedback\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n// --- Constants ---\nvar INPUTS = ['input', 'select', 'textarea']; // Selector for finding first input in the form group\n\nvar INPUT_SELECTOR = INPUTS.map(function (v) {\n  return \"\".concat(v, \":not([disabled])\");\n}).join(); // A list of interactive elements (tag names) inside `<b-form-group>`'s legend\n\nvar LEGEND_INTERACTIVE_ELEMENTS = [].concat(INPUTS, ['a', 'button', 'label']); // --- Props ---\n// Prop generator for lazy generation of props\n\nvar generateProps = function generateProps() {\n  return (0, _props2.makePropsConfigurable)((0, _object.sortKeys)(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, _id.props), _formState.props), (0, _config.getBreakpointsUpCached)().reduce(function (props, breakpoint) {\n    // i.e. 'content-cols', 'content-cols-sm', 'content-cols-md', ...\n    props[(0, _props2.suffixPropName)(breakpoint, 'contentCols')] = (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN_NUMBER_STRING); // i.e. 'label-align', 'label-align-sm', 'label-align-md', ...\n\n    props[(0, _props2.suffixPropName)(breakpoint, 'labelAlign')] = (0, _props2.makeProp)(_props.PROP_TYPE_STRING); // i.e. 'label-cols', 'label-cols-sm', 'label-cols-md', ...\n\n    props[(0, _props2.suffixPropName)(breakpoint, 'labelCols')] = (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN_NUMBER_STRING);\n    return props;\n  }, (0, _object.create)(null))), {}, {\n    description: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n    disabled: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n    feedbackAriaLive: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'assertive'),\n    invalidFeedback: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n    label: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n    labelClass: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_OBJECT_STRING),\n    labelFor: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n    labelSize: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n    labelSrOnly: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n    tooltip: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n    validFeedback: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n    validated: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false)\n  })), _components.NAME_FORM_GROUP);\n}; // --- Main component ---\n// We do not use `Vue.extend()` here as that would evaluate the props\n// immediately, which we do not want to happen\n// @vue/component\n\n\nexports.generateProps = generateProps;\nvar BFormGroup = {\n  name: _components.NAME_FORM_GROUP,\n  mixins: [_id.idMixin, _formState.formStateMixin, _normalizeSlot.normalizeSlotMixin],\n\n  get props() {\n    // Allow props to be lazy evaled on first access and\n    // then they become a non-getter afterwards\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#Smart_self-overwriting_lazy_getters\n    delete this.props; // eslint-disable-next-line no-return-assign\n\n    return this.props = generateProps();\n  },\n\n  data: function data() {\n    return {\n      ariaDescribedby: null\n    };\n  },\n  computed: {\n    contentColProps: function contentColProps() {\n      return this.getColProps(this.$props, 'content');\n    },\n    labelAlignClasses: function labelAlignClasses() {\n      return this.getAlignClasses(this.$props, 'label');\n    },\n    labelColProps: function labelColProps() {\n      return this.getColProps(this.$props, 'label');\n    },\n    isHorizontal: function isHorizontal() {\n      // Determine if the form group will be rendered horizontal\n      // based on the existence of 'content-col' or 'label-col' props\n      return (0, _object.keys)(this.contentColProps).length > 0 || (0, _object.keys)(this.labelColProps).length > 0;\n    }\n  },\n  watch: {\n    ariaDescribedby: function ariaDescribedby(newValue, oldValue) {\n      if (newValue !== oldValue) {\n        this.updateAriaDescribedby(newValue, oldValue);\n      }\n    }\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.$nextTick(function () {\n      // Set `aria-describedby` on the input specified by `labelFor`\n      // We do this in a `$nextTick()` to ensure the children have finished rendering\n      _this.updateAriaDescribedby(_this.ariaDescribedby);\n    });\n  },\n  methods: {\n    getAlignClasses: function getAlignClasses(props, prefix) {\n      return (0, _config.getBreakpointsUpCached)().reduce(function (result, breakpoint) {\n        var propValue = props[(0, _props2.suffixPropName)(breakpoint, \"\".concat(prefix, \"Align\"))] || null;\n\n        if (propValue) {\n          result.push(['text', breakpoint, propValue].filter(_identity.identity).join('-'));\n        }\n\n        return result;\n      }, []);\n    },\n    getColProps: function getColProps(props, prefix) {\n      return (0, _config.getBreakpointsUpCached)().reduce(function (result, breakpoint) {\n        var propValue = props[(0, _props2.suffixPropName)(breakpoint, \"\".concat(prefix, \"Cols\"))]; // Handle case where the prop's value is an empty string,\n        // which represents `true`\n\n        propValue = propValue === '' ? true : propValue || false;\n\n        if (!(0, _inspect.isBoolean)(propValue) && propValue !== 'auto') {\n          // Convert to column size to number\n          propValue = (0, _number.toInteger)(propValue, 0); // Ensure column size is greater than `0`\n\n          propValue = propValue > 0 ? propValue : false;\n        } // Add the prop to the list of props to give to `<b-col>`\n        // If breakpoint is '' (`${prefix}Cols` is `true`), then we use\n        // the 'col' prop to make equal width at 'xs'\n\n\n        if (propValue) {\n          result[breakpoint || ((0, _inspect.isBoolean)(propValue) ? 'col' : 'cols')] = propValue;\n        }\n\n        return result;\n      }, {});\n    },\n    // Sets the `aria-describedby` attribute on the input if `labelFor` is set\n    // Optionally accepts a string of IDs to remove as the second parameter\n    // Preserves any `aria-describedby` value(s) user may have on input\n    updateAriaDescribedby: function updateAriaDescribedby(newValue, oldValue) {\n      var labelFor = this.labelFor;\n\n      if (_env.IS_BROWSER && labelFor) {\n        // We need to escape `labelFor` since it can be user-provided\n        var $input = (0, _dom.select)(\"#\".concat((0, _cssEscape.cssEscape)(labelFor)), this.$refs.content);\n\n        if ($input) {\n          var attr = 'aria-describedby';\n          var newIds = (newValue || '').split(_regex.RX_SPACE_SPLIT);\n          var oldIds = (oldValue || '').split(_regex.RX_SPACE_SPLIT); // Update ID list, preserving any original IDs\n          // and ensuring the ID's are unique\n\n          var ids = ((0, _dom.getAttr)($input, attr) || '').split(_regex.RX_SPACE_SPLIT).filter(function (id) {\n            return !(0, _array.arrayIncludes)(oldIds, id);\n          }).concat(newIds).filter(function (id, index, ids) {\n            return ids.indexOf(id) === index;\n          }).filter(_identity.identity).join(' ').trim();\n\n          if (ids) {\n            (0, _dom.setAttr)($input, attr, ids);\n          } else {\n            (0, _dom.removeAttr)($input, attr);\n          }\n        }\n      }\n    },\n    onLegendClick: function onLegendClick(event) {\n      // Don't do anything if `labelFor` is set\n\n      /* istanbul ignore next: clicking a label will focus the input, so no need to test */\n      if (this.labelFor) {\n        return;\n      }\n\n      var target = event.target;\n      var tagName = target ? target.tagName : ''; // If clicked an interactive element inside legend,\n      // we just let the default happen\n\n      /* istanbul ignore next */\n\n      if (LEGEND_INTERACTIVE_ELEMENTS.indexOf(tagName) !== -1) {\n        return;\n      } // If only a single input, focus it, emulating label behaviour\n\n\n      var inputs = (0, _dom.selectAll)(INPUT_SELECTOR, this.$refs.content).filter(_dom.isVisible);\n\n      if (inputs.length === 1) {\n        (0, _dom.attemptFocus)(inputs[0]);\n      }\n    }\n  },\n  render: function render(h) {\n    var state = this.computedState,\n        feedbackAriaLive = this.feedbackAriaLive,\n        isHorizontal = this.isHorizontal,\n        labelFor = this.labelFor,\n        normalizeSlot = this.normalizeSlot,\n        safeId = this.safeId,\n        tooltip = this.tooltip;\n    var id = safeId();\n    var isFieldset = !labelFor;\n    var $label = h();\n    var labelContent = normalizeSlot(_slots.SLOT_NAME_LABEL) || this.label;\n    var labelId = labelContent ? safeId('_BV_label_') : null;\n\n    if (labelContent || isHorizontal) {\n      var labelSize = this.labelSize,\n          labelColProps = this.labelColProps;\n      var labelTag = isFieldset ? 'legend' : 'label';\n\n      if (this.labelSrOnly) {\n        if (labelContent) {\n          $label = h(labelTag, {\n            class: 'sr-only',\n            attrs: {\n              id: labelId,\n              for: labelFor || null\n            }\n          }, [labelContent]);\n        }\n\n        $label = h(isHorizontal ? _col.BCol : 'div', {\n          props: isHorizontal ? labelColProps : {}\n        }, [$label]);\n      } else {\n        $label = h(isHorizontal ? _col.BCol : labelTag, {\n          on: isFieldset ? {\n            click: this.onLegendClick\n          } : {},\n          props: isHorizontal ? _objectSpread(_objectSpread({}, labelColProps), {}, {\n            tag: labelTag\n          }) : {},\n          attrs: {\n            id: labelId,\n            for: labelFor || null,\n            // We add a `tabindex` to legend so that screen readers\n            // will properly read the `aria-labelledby` in IE\n            tabindex: isFieldset ? '-1' : null\n          },\n          class: [// Hide the focus ring on the legend\n          isFieldset ? 'bv-no-focus-ring' : '', // When horizontal or if a legend is rendered, add 'col-form-label' class\n          // for correct sizing as Bootstrap has inconsistent font styling for\n          // legend in non-horizontal form groups\n          // See: https://github.com/twbs/bootstrap/issues/27805\n          isHorizontal || isFieldset ? 'col-form-label' : '', // Emulate label padding top of `0` on legend when not horizontal\n          !isHorizontal && isFieldset ? 'pt-0' : '', // If not horizontal and not a legend, we add 'd-block' class to label\n          // so that label-align works\n          !isHorizontal && !isFieldset ? 'd-block' : '', labelSize ? \"col-form-label-\".concat(labelSize) : '', this.labelAlignClasses, this.labelClass]\n        }, [labelContent]);\n      }\n    }\n\n    var $invalidFeedback = h();\n    var invalidFeedbackContent = normalizeSlot(_slots.SLOT_NAME_INVALID_FEEDBACK) || this.invalidFeedback;\n    var invalidFeedbackId = invalidFeedbackContent ? safeId('_BV_feedback_invalid_') : null;\n\n    if (invalidFeedbackContent) {\n      $invalidFeedback = h(_formInvalidFeedback.BFormInvalidFeedback, {\n        props: {\n          ariaLive: feedbackAriaLive,\n          id: invalidFeedbackId,\n          role: feedbackAriaLive ? 'alert' : null,\n          // If state is explicitly `false`, always show the feedback\n          state: state,\n          tooltip: tooltip\n        },\n        attrs: {\n          tabindex: invalidFeedbackContent ? '-1' : null\n        }\n      }, [invalidFeedbackContent]);\n    }\n\n    var $validFeedback = h();\n    var validFeedbackContent = normalizeSlot(_slots.SLOT_NAME_VALID_FEEDBACK) || this.validFeedback;\n    var validFeedbackId = validFeedbackContent ? safeId('_BV_feedback_valid_') : null;\n\n    if (validFeedbackContent) {\n      $validFeedback = h(_formValidFeedback.BFormValidFeedback, {\n        props: {\n          ariaLive: feedbackAriaLive,\n          id: validFeedbackId,\n          role: feedbackAriaLive ? 'alert' : null,\n          // If state is explicitly `true`, always show the feedback\n          state: state,\n          tooltip: tooltip\n        },\n        attrs: {\n          tabindex: validFeedbackContent ? '-1' : null\n        }\n      }, [validFeedbackContent]);\n    }\n\n    var $description = h();\n    var descriptionContent = normalizeSlot(_slots.SLOT_NAME_DESCRIPTION) || this.description;\n    var descriptionId = descriptionContent ? safeId('_BV_description_') : null;\n\n    if (descriptionContent) {\n      $description = h(_formText.BFormText, {\n        attrs: {\n          id: descriptionId,\n          tabindex: '-1'\n        }\n      }, [descriptionContent]);\n    } // Update `ariaDescribedby`\n    // Screen readers will read out any content linked to by `aria-describedby`\n    // even if the content is hidden with `display: none;`, hence we only include\n    // feedback IDs if the form group's state is explicitly valid or invalid\n\n\n    var ariaDescribedby = this.ariaDescribedby = [descriptionId, state === false ? invalidFeedbackId : null, state === true ? validFeedbackId : null].filter(_identity.identity).join(' ') || null;\n    var $content = h(isHorizontal ? _col.BCol : 'div', {\n      props: isHorizontal ? this.contentColProps : {},\n      ref: 'content'\n    }, [normalizeSlot(_slots.SLOT_NAME_DEFAULT, {\n      ariaDescribedby: ariaDescribedby,\n      descriptionId: descriptionId,\n      id: id,\n      labelId: labelId\n    }) || h(), $invalidFeedback, $validFeedback, $description]); // Return it wrapped in a form group\n    // Note: Fieldsets do not support adding `row` or `form-row` directly\n    // to them due to browser specific render issues, so we move the `form-row`\n    // to an inner wrapper div when horizontal and using a fieldset\n\n    return h(isFieldset ? 'fieldset' : isHorizontal ? _formRow.BFormRow : 'div', {\n      staticClass: 'form-group',\n      class: [{\n        'was-validated': this.validated\n      }, this.stateClass],\n      attrs: {\n        id: id,\n        disabled: isFieldset ? this.disabled : null,\n        role: isFieldset ? null : 'group',\n        'aria-invalid': this.computedAriaInvalid,\n        // Only apply `aria-labelledby` if we are a horizontal fieldset\n        // as the legend is no longer a direct child of fieldset\n        'aria-labelledby': isFieldset && isHorizontal ? labelId : null\n      }\n    }, isHorizontal && isFieldset ? [h(_formRow.BFormRow, [$label, $content])] : [$label, $content]);\n  }\n};\nexports.BFormGroup = BFormGroup;"},"sourceMaps":null,"error":null,"hash":"7c97c6ea210c87f7ae2678ea7d0fdbe3","cacheData":{"env":{}}}