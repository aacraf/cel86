{"id":"../node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"../../../vue","loc":{"line":7,"column":20,"index":1110},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/vue.js"},{"name":"../../../constants/events","loc":{"line":8,"column":125,"index":1251},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/events.js"},{"name":"../../../constants/key-codes","loc":{"line":9,"column":80,"index":1360},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/key-codes.js"},{"name":"../../../constants/props","loc":{"line":10,"column":46,"index":1438},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/props.js"},{"name":"../../../utils/array","loc":{"line":11,"column":49,"index":1515},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/array.js"},{"name":"../../../utils/dom","loc":{"line":12,"column":66,"index":1605},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/dom.js"},{"name":"../../../utils/events","loc":{"line":13,"column":26,"index":1653},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/events.js"},{"name":"../../../utils/object","loc":{"line":14,"column":25,"index":1703},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/object.js"},{"name":"../../../utils/props","loc":{"line":15,"column":37,"index":1765},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js"},{"name":"../tbody","loc":{"line":16,"column":45,"index":1834},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/tbody.js"},{"name":"./filter-event","loc":{"line":17,"column":28,"index":1874},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/filter-event.js"},{"name":"./text-selection-active","loc":{"line":18,"column":36,"index":1928},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/text-selection-active.js"},{"name":"./mixin-tbody-row","loc":{"line":19,"column":54,"index":2009},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-tbody-row.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tbodyMixin = exports.props = void 0;\n\nvar _vue = require(\"../../../vue\");\n\nvar _events = require(\"../../../constants/events\");\n\nvar _keyCodes = require(\"../../../constants/key-codes\");\n\nvar _props = require(\"../../../constants/props\");\n\nvar _array = require(\"../../../utils/array\");\n\nvar _dom = require(\"../../../utils/dom\");\n\nvar _events2 = require(\"../../../utils/events\");\n\nvar _object = require(\"../../../utils/object\");\n\nvar _props2 = require(\"../../../utils/props\");\n\nvar _tbody = require(\"../tbody\");\n\nvar _filterEvent = require(\"./filter-event\");\n\nvar _textSelectionActive = require(\"./text-selection-active\");\n\nvar _mixinTbodyRow = require(\"./mixin-tbody-row\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n// --- Helper methods ---\nvar getCellSlotName = function getCellSlotName(value) {\n  return \"cell(\".concat(value || '', \")\");\n}; // --- Props ---\n\n\nvar props = (0, _object.sortKeys)(_objectSpread(_objectSpread(_objectSpread({}, _tbody.props), _mixinTbodyRow.props), {}, {\n  tbodyClass: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_OBJECT_STRING)\n})); // --- Mixin ---\n// @vue/component\n\nexports.props = props;\n\nvar tbodyMixin = _vue.Vue.extend({\n  mixins: [_mixinTbodyRow.tbodyRowMixin],\n  props: props,\n  beforeDestroy: function beforeDestroy() {\n    this.$_bodyFieldSlotNameCache = null;\n  },\n  methods: {\n    // Returns all the item TR elements (excludes detail and spacer rows)\n    // `this.$refs['item-rows']` is an array of item TR components/elements\n    // Rows should all be `<b-tr>` components, but we map to TR elements\n    // Also note that `this.$refs['item-rows']` may not always be in document order\n    getTbodyTrs: function getTbodyTrs() {\n      var $refs = this.$refs;\n      var tbody = $refs.tbody ? $refs.tbody.$el || $refs.tbody : null;\n      var trs = ($refs['item-rows'] || []).map(function (tr) {\n        return tr.$el || tr;\n      });\n      return tbody && tbody.children && tbody.children.length > 0 && trs && trs.length > 0 ? (0, _array.from)(tbody.children).filter(function (tr) {\n        return (0, _array.arrayIncludes)(trs, tr);\n      }) :\n      /* istanbul ignore next */\n      [];\n    },\n    // Returns index of a particular TBODY item TR\n    // We set `true` on closest to include self in result\n    getTbodyTrIndex: function getTbodyTrIndex(el) {\n      /* istanbul ignore next: should not normally happen */\n      if (!(0, _dom.isElement)(el)) {\n        return -1;\n      }\n\n      var tr = el.tagName === 'TR' ? el : (0, _dom.closest)('tr', el, true);\n      return tr ? this.getTbodyTrs().indexOf(tr) : -1;\n    },\n    // Emits a row event, with the item object, row index and original event\n    emitTbodyRowEvent: function emitTbodyRowEvent(type, event) {\n      if (type && this.hasListener(type) && event && event.target) {\n        var rowIndex = this.getTbodyTrIndex(event.target);\n\n        if (rowIndex > -1) {\n          // The array of TRs correlate to the `computedItems` array\n          var item = this.computedItems[rowIndex];\n          this.$emit(type, item, rowIndex, event);\n        }\n      }\n    },\n    tbodyRowEvtStopped: function tbodyRowEvtStopped(event) {\n      return this.stopIfBusy && this.stopIfBusy(event);\n    },\n    // Delegated row event handlers\n    onTbodyRowKeydown: function onTbodyRowKeydown(event) {\n      // Keyboard navigation and row click emulation\n      var target = event.target,\n          keyCode = event.keyCode;\n\n      if (this.tbodyRowEvtStopped(event) || target.tagName !== 'TR' || !(0, _dom.isActiveElement)(target) || target.tabIndex !== 0) {\n        // Early exit if not an item row TR\n        return;\n      }\n\n      if ((0, _array.arrayIncludes)([_keyCodes.CODE_ENTER, _keyCodes.CODE_SPACE], keyCode)) {\n        // Emulated click for keyboard users, transfer to click handler\n        (0, _events2.stopEvent)(event);\n        this.onTBodyRowClicked(event);\n      } else if ((0, _array.arrayIncludes)([_keyCodes.CODE_UP, _keyCodes.CODE_DOWN, _keyCodes.CODE_HOME, _keyCodes.CODE_END], keyCode)) {\n        // Keyboard navigation\n        var rowIndex = this.getTbodyTrIndex(target);\n\n        if (rowIndex > -1) {\n          (0, _events2.stopEvent)(event);\n          var trs = this.getTbodyTrs();\n          var shift = event.shiftKey;\n\n          if (keyCode === _keyCodes.CODE_HOME || shift && keyCode === _keyCodes.CODE_UP) {\n            // Focus first row\n            (0, _dom.attemptFocus)(trs[0]);\n          } else if (keyCode === _keyCodes.CODE_END || shift && keyCode === _keyCodes.CODE_DOWN) {\n            // Focus last row\n            (0, _dom.attemptFocus)(trs[trs.length - 1]);\n          } else if (keyCode === _keyCodes.CODE_UP && rowIndex > 0) {\n            // Focus previous row\n            (0, _dom.attemptFocus)(trs[rowIndex - 1]);\n          } else if (keyCode === _keyCodes.CODE_DOWN && rowIndex < trs.length - 1) {\n            // Focus next row\n            (0, _dom.attemptFocus)(trs[rowIndex + 1]);\n          }\n        }\n      }\n    },\n    onTBodyRowClicked: function onTBodyRowClicked(event) {\n      // Don't emit event when the table is busy, the user clicked\n      // on a non-disabled control or is selecting text\n      if (this.tbodyRowEvtStopped(event) || (0, _filterEvent.filterEvent)(event) || (0, _textSelectionActive.textSelectionActive)(this.$el)) {\n        return;\n      }\n\n      this.emitTbodyRowEvent(_events.EVENT_NAME_ROW_CLICKED, event);\n    },\n    onTbodyRowMiddleMouseRowClicked: function onTbodyRowMiddleMouseRowClicked(event) {\n      if (!this.tbodyRowEvtStopped(event) && event.which === 2) {\n        this.emitTbodyRowEvent(_events.EVENT_NAME_ROW_MIDDLE_CLICKED, event);\n      }\n    },\n    onTbodyRowContextmenu: function onTbodyRowContextmenu(event) {\n      if (!this.tbodyRowEvtStopped(event)) {\n        this.emitTbodyRowEvent(_events.EVENT_NAME_ROW_CONTEXTMENU, event);\n      }\n    },\n    onTbodyRowDblClicked: function onTbodyRowDblClicked(event) {\n      if (!this.tbodyRowEvtStopped(event) && !(0, _filterEvent.filterEvent)(event)) {\n        this.emitTbodyRowEvent(_events.EVENT_NAME_ROW_DBLCLICKED, event);\n      }\n    },\n    // Render the tbody element and children\n    // Note:\n    //   Row hover handlers are handled by the tbody-row mixin\n    //   As mouseenter/mouseleave events do not bubble\n    renderTbody: function renderTbody() {\n      var _this = this;\n\n      var items = this.computedItems,\n          renderBusy = this.renderBusy,\n          renderTopRow = this.renderTopRow,\n          renderEmpty = this.renderEmpty,\n          renderBottomRow = this.renderBottomRow;\n      var h = this.$createElement;\n      var hasRowClickHandler = this.hasListener(_events.EVENT_NAME_ROW_CLICKED) || this.hasSelectableRowClick; // Prepare the tbody rows\n\n      var $rows = []; // Add the item data rows or the busy slot\n\n      var $busy = renderBusy ? renderBusy() : null;\n\n      if ($busy) {\n        // If table is busy and a busy slot, then return only the busy \"row\" indicator\n        $rows.push($busy);\n      } else {\n        // Table isn't busy, or we don't have a busy slot\n        // Create a slot cache for improved performance when looking up cell slot names\n        // Values will be keyed by the field's `key` and will store the slot's name\n        // Slots could be dynamic (i.e. `v-if`), so we must compute on each render\n        // Used by tbody-row mixin render helper\n        var cache = {};\n        var defaultSlotName = getCellSlotName();\n        defaultSlotName = this.hasNormalizedSlot(defaultSlotName) ? defaultSlotName : null;\n        this.computedFields.forEach(function (field) {\n          var key = field.key;\n          var slotName = getCellSlotName(key);\n          var lowercaseSlotName = getCellSlotName(key.toLowerCase());\n          cache[key] = _this.hasNormalizedSlot(slotName) ? slotName : _this.hasNormalizedSlot(lowercaseSlotName) ?\n          /* istanbul ignore next */\n          lowercaseSlotName : defaultSlotName;\n        }); // Created as a non-reactive property so to not trigger component updates\n        // Must be a fresh object each render\n\n        this.$_bodyFieldSlotNameCache = cache; // Add static top row slot (hidden in visibly stacked mode\n        // as we can't control `data-label` attr)\n\n        $rows.push(renderTopRow ? renderTopRow() : h()); // Render the rows\n\n        items.forEach(function (item, rowIndex) {\n          // Render the individual item row (rows if details slot)\n          $rows.push(_this.renderTbodyRow(item, rowIndex));\n        }); // Empty items / empty filtered row slot (only shows if `items.length < 1`)\n\n        $rows.push(renderEmpty ? renderEmpty() : h()); // Static bottom row slot (hidden in visibly stacked mode\n        // as we can't control `data-label` attr)\n\n        $rows.push(renderBottomRow ? renderBottomRow() : h());\n      } // Note: these events will only emit if a listener is registered\n\n\n      var handlers = {\n        auxclick: this.onTbodyRowMiddleMouseRowClicked,\n        // TODO:\n        //   Perhaps we do want to automatically prevent the\n        //   default context menu from showing if there is a\n        //   `row-contextmenu` listener registered\n        contextmenu: this.onTbodyRowContextmenu,\n        // The following event(s) is not considered A11Y friendly\n        dblclick: this.onTbodyRowDblClicked // Hover events (`mouseenter`/`mouseleave`) are handled by `tbody-row` mixin\n\n      }; // Add in click/keydown listeners if needed\n\n      if (hasRowClickHandler) {\n        handlers.click = this.onTBodyRowClicked;\n        handlers.keydown = this.onTbodyRowKeydown;\n      } // Assemble rows into the tbody\n\n\n      var $tbody = h(_tbody.BTbody, {\n        class: this.tbodyClass || null,\n        props: (0, _props2.pluckProps)(_tbody.props, this.$props),\n        // BTbody transfers all native event listeners to the root element\n        // TODO: Only set the handlers if the table is not busy\n        on: handlers,\n        ref: 'tbody'\n      }, $rows); // Return the assembled tbody\n\n      return $tbody;\n    }\n  }\n});\n\nexports.tbodyMixin = tbodyMixin;"},"sourceMaps":null,"error":null,"hash":"e3f6025d691ffb8b7b0619557144bb8a","cacheData":{"env":{}}}