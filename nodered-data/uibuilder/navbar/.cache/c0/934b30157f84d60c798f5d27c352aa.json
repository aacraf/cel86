{"id":"../node_modules/bootstrap-vue/esm/utils/props.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"../constants/props","loc":{"line":7,"column":30,"index":1120},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/props.js"},{"name":"./clone-deep","loc":{"line":8,"column":26,"index":1168},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/clone-deep.js"},{"name":"./config","loc":{"line":9,"column":35,"index":1219},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/config.js"},{"name":"./identity","loc":{"line":10,"column":25,"index":1256},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/identity.js"},{"name":"./inspect","loc":{"line":11,"column":59,"index":1329},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/inspect.js"},{"name":"./object","loc":{"line":12,"column":44,"index":1386},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/object.js"},{"name":"./string","loc":{"line":13,"column":39,"index":1437},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/string.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unprefixPropName = exports.suffixPropName = exports.prefixPropName = exports.pluckProps = exports.makePropsConfigurable = exports.makePropConfigurable = exports.makeProp = exports.hasPropFunction = exports.copyProps = void 0;\n\nvar _props = require(\"../constants/props\");\n\nvar _cloneDeep = require(\"./clone-deep\");\n\nvar _config = require(\"./config\");\n\nvar _identity = require(\"./identity\");\n\nvar _inspect = require(\"./inspect\");\n\nvar _object = require(\"./object\");\n\nvar _string = require(\"./string\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n// Prefix a property\nvar prefixPropName = function prefixPropName(prefix, value) {\n  return prefix + (0, _string.upperFirst)(value);\n}; // Remove a prefix from a property\n\n\nexports.prefixPropName = prefixPropName;\n\nvar unprefixPropName = function unprefixPropName(prefix, value) {\n  return (0, _string.lowerFirst)(value.replace(prefix, ''));\n}; // Suffix can be a falsey value so nothing is appended to string\n// (helps when looping over props & some shouldn't change)\n// Use data last parameters to allow for currying\n\n\nexports.unprefixPropName = unprefixPropName;\n\nvar suffixPropName = function suffixPropName(suffix, value) {\n  return value + (suffix ? (0, _string.upperFirst)(suffix) : '');\n}; // Generates a prop object\n\n\nexports.suffixPropName = suffixPropName;\n\nvar makeProp = function makeProp() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _props.PROP_TYPE_ANY;\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  var requiredOrValidator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  var validator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n  var required = requiredOrValidator === true;\n  validator = required ? validator : requiredOrValidator;\n  return _objectSpread(_objectSpread(_objectSpread({}, type ? {\n    type: type\n  } : {}), required ? {\n    required: required\n  } : (0, _inspect.isUndefined)(value) ? {} : {\n    default: (0, _inspect.isObject)(value) ? function () {\n      return value;\n    } : value\n  }), (0, _inspect.isUndefined)(validator) ? {} : {\n    validator: validator\n  });\n}; // Copies props from one array/object to a new array/object\n// Prop values are also cloned as new references to prevent possible\n// mutation of original prop object values\n// Optionally accepts a function to transform the prop name\n\n\nexports.makeProp = makeProp;\n\nvar copyProps = function copyProps(props) {\n  var transformFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _identity.identity;\n\n  if ((0, _inspect.isArray)(props)) {\n    return props.map(transformFn);\n  }\n\n  var copied = {};\n\n  for (var prop in props) {\n    /* istanbul ignore else */\n    if ((0, _object.hasOwnProperty)(props, prop)) {\n      // If the prop value is an object, do a shallow clone\n      // to prevent potential mutations to the original object\n      copied[transformFn(prop)] = (0, _inspect.isObject)(props[prop]) ? (0, _object.clone)(props[prop]) : props[prop];\n    }\n  }\n\n  return copied;\n}; // Given an array of properties or an object of property keys,\n// plucks all the values off the target object, returning a new object\n// that has props that reference the original prop values\n\n\nexports.copyProps = copyProps;\n\nvar pluckProps = function pluckProps(keysToPluck, objToPluck) {\n  var transformFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _identity.identity;\n  return ((0, _inspect.isArray)(keysToPluck) ? keysToPluck.slice() : (0, _object.keys)(keysToPluck)).reduce(function (memo, prop) {\n    memo[transformFn(prop)] = objToPluck[prop];\n    return memo;\n  }, {});\n}; // Make a prop object configurable by global configuration\n// Replaces the current `default` key of each prop with a `getComponentConfig()`\n// call that falls back to the current default value of the prop\n\n\nexports.pluckProps = pluckProps;\n\nvar makePropConfigurable = function makePropConfigurable(prop, key, componentKey) {\n  return _objectSpread(_objectSpread({}, (0, _cloneDeep.cloneDeep)(prop)), {}, {\n    default: function bvConfigurablePropDefault() {\n      var value = (0, _config.getComponentConfig)(componentKey, key, prop.default);\n      return (0, _inspect.isFunction)(value) ? value() : value;\n    }\n  });\n}; // Make a props object configurable by global configuration\n// Replaces the current `default` key of each prop with a `getComponentConfig()`\n// call that falls back to the current default value of the prop\n\n\nexports.makePropConfigurable = makePropConfigurable;\n\nvar makePropsConfigurable = function makePropsConfigurable(props, componentKey) {\n  return (0, _object.keys)(props).reduce(function (result, key) {\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, key, makePropConfigurable(props[key], key, componentKey)));\n  }, {});\n}; // Get function name we use in `makePropConfigurable()`\n// for the prop default value override to compare\n// against in `hasPropFunction()`\n\n\nexports.makePropsConfigurable = makePropsConfigurable;\nvar configurablePropDefaultFnName = makePropConfigurable({}, '', '').default.name; // Detect wether the given value is currently a function\n// and isn't the props default function\n\nvar hasPropFunction = function hasPropFunction(fn) {\n  return (0, _inspect.isFunction)(fn) && fn.name !== configurablePropDefaultFnName;\n};\n\nexports.hasPropFunction = hasPropFunction;"},"sourceMaps":null,"error":null,"hash":"00cef0f26cacdc30f7f2b139fcb4f866","cacheData":{"env":{}}}