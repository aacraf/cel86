{"id":"../node_modules/bootstrap-vue/esm/components/carousel/carousel.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"../../vue","loc":{"line":9,"column":20,"index":1123},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/vue.js"},{"name":"../../constants/components","loc":{"line":10,"column":30,"index":1166},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/components.js"},{"name":"../../constants/env","loc":{"line":11,"column":73,"index":1269},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/env.js"},{"name":"../../constants/events","loc":{"line":12,"column":131,"index":1423},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/events.js"},{"name":"../../constants/key-codes","loc":{"line":13,"column":62,"index":1511},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/key-codes.js"},{"name":"../../constants/props","loc":{"line":14,"column":95,"index":1635},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/props.js"},{"name":"../../utils/dom","loc":{"line":15,"column":95,"index":1755},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/dom.js"},{"name":"../../utils/events","loc":{"line":16,"column":45,"index":1819},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/events.js"},{"name":"../../utils/inspect","loc":{"line":17,"column":28,"index":1869},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/inspect.js"},{"name":"../../utils/math","loc":{"line":18,"column":53,"index":1945},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/math.js"},{"name":"../../utils/model","loc":{"line":19,"column":31,"index":1996},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/model.js"},{"name":"../../utils/number","loc":{"line":20,"column":26,"index":2043},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/number.js"},{"name":"../../utils/noop","loc":{"line":21,"column":21,"index":2086},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/noop.js"},{"name":"../../utils/object","loc":{"line":22,"column":25,"index":2131},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/object.js"},{"name":"../../utils/observe-dom","loc":{"line":23,"column":27,"index":2180},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/observe-dom.js"},{"name":"../../utils/props","loc":{"line":24,"column":48,"index":2255},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js"},{"name":"../../mixins/id","loc":{"line":25,"column":42,"index":2318},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/id.js"},{"name":"../../mixins/normalize-slot","loc":{"line":26,"column":35,"index":2372},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/carousel/carousel.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/normalize-slot.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.props = exports.BCarousel = void 0;\n\nvar _vue = require(\"../../vue\");\n\nvar _components = require(\"../../constants/components\");\n\nvar _env = require(\"../../constants/env\");\n\nvar _events = require(\"../../constants/events\");\n\nvar _keyCodes = require(\"../../constants/key-codes\");\n\nvar _props = require(\"../../constants/props\");\n\nvar _dom = require(\"../../utils/dom\");\n\nvar _events2 = require(\"../../utils/events\");\n\nvar _inspect = require(\"../../utils/inspect\");\n\nvar _math = require(\"../../utils/math\");\n\nvar _model = require(\"../../utils/model\");\n\nvar _number = require(\"../../utils/number\");\n\nvar _noop = require(\"../../utils/noop\");\n\nvar _object = require(\"../../utils/object\");\n\nvar _observeDom = require(\"../../utils/observe-dom\");\n\nvar _props2 = require(\"../../utils/props\");\n\nvar _id = require(\"../../mixins/id\");\n\nvar _normalizeSlot = require(\"../../mixins/normalize-slot\");\n\nvar _watch;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n// --- Constants ---\nvar _makeModelMixin = (0, _model.makeModelMixin)('value', {\n  type: _props.PROP_TYPE_NUMBER,\n  defaultValue: 0\n}),\n    modelMixin = _makeModelMixin.mixin,\n    modelProps = _makeModelMixin.props,\n    MODEL_PROP_NAME = _makeModelMixin.prop,\n    MODEL_EVENT_NAME = _makeModelMixin.event; // Slide directional classes\n\n\nvar DIRECTION = {\n  next: {\n    dirClass: 'carousel-item-left',\n    overlayClass: 'carousel-item-next'\n  },\n  prev: {\n    dirClass: 'carousel-item-right',\n    overlayClass: 'carousel-item-prev'\n  }\n}; // Fallback Transition duration (with a little buffer) in ms\n\nvar TRANS_DURATION = 600 + 50; // Time for mouse compat events to fire after touch\n\nvar TOUCH_EVENT_COMPAT_WAIT = 500; // Number of pixels to consider touch move a swipe\n\nvar SWIPE_THRESHOLD = 40; // PointerEvent pointer types\n\nvar PointerType = {\n  TOUCH: 'touch',\n  PEN: 'pen'\n}; // Transition Event names\n\nvar TransitionEndEvents = {\n  WebkitTransition: 'webkitTransitionEnd',\n  MozTransition: 'transitionend',\n  OTransition: 'otransitionend oTransitionEnd',\n  transition: 'transitionend'\n}; // --- Helper methods ---\n// Return the browser specific transitionEnd event name\n\nvar getTransitionEndEvent = function getTransitionEndEvent(el) {\n  for (var name in TransitionEndEvents) {\n    if (!(0, _inspect.isUndefined)(el.style[name])) {\n      return TransitionEndEvents[name];\n    }\n  } // Fallback\n\n  /* istanbul ignore next */\n\n\n  return null;\n}; // --- Props ---\n\n\nvar props = (0, _props2.makePropsConfigurable)((0, _object.sortKeys)(_objectSpread(_objectSpread(_objectSpread({}, _id.props), modelProps), {}, {\n  background: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n  controls: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // Enable cross-fade animation instead of slide animation\n  fade: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // Sniffed by carousel-slide\n  imgHeight: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING),\n  // Sniffed by carousel-slide\n  imgWidth: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING),\n  indicators: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  interval: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER, 5000),\n  labelGotoSlide: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Goto slide'),\n  labelIndicators: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Select a slide to display'),\n  labelNext: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Next slide'),\n  labelPrev: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Previous slide'),\n  // Disable slide/fade animation\n  noAnimation: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // Disable pause on hover\n  noHoverPause: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // Sniffed by carousel-slide\n  noTouch: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // Disable wrapping/looping when start/end is reached\n  noWrap: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false)\n})), _components.NAME_CAROUSEL); // --- Main component ---\n// @vue/component\n\nexports.props = props;\n\nvar BCarousel = /*#__PURE__*/_vue.Vue.extend({\n  name: _components.NAME_CAROUSEL,\n  mixins: [_id.idMixin, modelMixin, _normalizeSlot.normalizeSlotMixin],\n  provide: function provide() {\n    return {\n      bvCarousel: this\n    };\n  },\n  props: props,\n  data: function data() {\n    return {\n      index: this[MODEL_PROP_NAME] || 0,\n      isSliding: false,\n      transitionEndEvent: null,\n      slides: [],\n      direction: null,\n      isPaused: !((0, _number.toInteger)(this.interval, 0) > 0),\n      // Touch event handling values\n      touchStartX: 0,\n      touchDeltaX: 0\n    };\n  },\n  computed: {\n    numSlides: function numSlides() {\n      return this.slides.length;\n    }\n  },\n  watch: (_watch = {}, _defineProperty(_watch, MODEL_PROP_NAME, function (newValue, oldValue) {\n    if (newValue !== oldValue) {\n      this.setSlide((0, _number.toInteger)(newValue, 0));\n    }\n  }), _defineProperty(_watch, \"interval\", function interval(newValue, oldValue) {\n    /* istanbul ignore next */\n    if (newValue === oldValue) {\n      return;\n    }\n\n    if (!newValue) {\n      // Pausing slide show\n      this.pause(false);\n    } else {\n      // Restarting or Changing interval\n      this.pause(true);\n      this.start(false);\n    }\n  }), _defineProperty(_watch, \"isPaused\", function isPaused(newValue, oldValue) {\n    if (newValue !== oldValue) {\n      this.$emit(newValue ? _events.EVENT_NAME_PAUSED : _events.EVENT_NAME_UNPAUSED);\n    }\n  }), _defineProperty(_watch, \"index\", function index(to, from) {\n    /* istanbul ignore next */\n    if (to === from || this.isSliding) {\n      return;\n    }\n\n    this.doSlide(to, from);\n  }), _watch),\n  created: function created() {\n    // Create private non-reactive props\n    this.$_interval = null;\n    this.$_animationTimeout = null;\n    this.$_touchTimeout = null;\n    this.$_observer = null; // Set initial paused state\n\n    this.isPaused = !((0, _number.toInteger)(this.interval, 0) > 0);\n  },\n  mounted: function mounted() {\n    // Cache current browser transitionend event name\n    this.transitionEndEvent = getTransitionEndEvent(this.$el) || null; // Get all slides\n\n    this.updateSlides(); // Observe child changes so we can update slide list\n\n    this.setObserver(true);\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.clearInterval();\n    this.clearAnimationTimeout();\n    this.clearTouchTimeout();\n    this.setObserver(false);\n  },\n  methods: {\n    clearInterval: function (_clearInterval) {\n      function clearInterval() {\n        return _clearInterval.apply(this, arguments);\n      }\n\n      clearInterval.toString = function () {\n        return _clearInterval.toString();\n      };\n\n      return clearInterval;\n    }(function () {\n      clearInterval(this.$_interval);\n      this.$_interval = null;\n    }),\n    clearAnimationTimeout: function clearAnimationTimeout() {\n      clearTimeout(this.$_animationTimeout);\n      this.$_animationTimeout = null;\n    },\n    clearTouchTimeout: function clearTouchTimeout() {\n      clearTimeout(this.$_touchTimeout);\n      this.$_touchTimeout = null;\n    },\n    setObserver: function setObserver() {\n      var on = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.$_observer && this.$_observer.disconnect();\n      this.$_observer = null;\n\n      if (on) {\n        this.$_observer = (0, _observeDom.observeDom)(this.$refs.inner, this.updateSlides.bind(this), {\n          subtree: false,\n          childList: true,\n          attributes: true,\n          attributeFilter: ['id']\n        });\n      }\n    },\n    // Set slide\n    setSlide: function setSlide(slide) {\n      var _this = this;\n\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; // Don't animate when page is not visible\n\n      /* istanbul ignore if: difficult to test */\n\n      if (_env.IS_BROWSER && document.visibilityState && document.hidden) {\n        return;\n      }\n\n      var noWrap = this.noWrap;\n      var numSlides = this.numSlides; // Make sure we have an integer (you never know!)\n\n      slide = (0, _math.mathFloor)(slide); // Don't do anything if nothing to slide to\n\n      if (numSlides === 0) {\n        return;\n      } // Don't change slide while transitioning, wait until transition is done\n\n\n      if (this.isSliding) {\n        // Schedule slide after sliding complete\n        this.$once(_events.EVENT_NAME_SLIDING_END, function () {\n          // Wrap in `requestAF()` to allow the slide to properly finish to avoid glitching\n          (0, _dom.requestAF)(function () {\n            return _this.setSlide(slide, direction);\n          });\n        });\n        return;\n      }\n\n      this.direction = direction; // Set new slide index\n      // Wrap around if necessary (if no-wrap not enabled)\n\n      this.index = slide >= numSlides ? noWrap ? numSlides - 1 : 0 : slide < 0 ? noWrap ? 0 : numSlides - 1 : slide; // Ensure the v-model is synched up if no-wrap is enabled\n      // and user tried to slide pass either ends\n\n      if (noWrap && this.index !== slide && this.index !== this[MODEL_PROP_NAME]) {\n        this.$emit(MODEL_EVENT_NAME, this.index);\n      }\n    },\n    // Previous slide\n    prev: function prev() {\n      this.setSlide(this.index - 1, 'prev');\n    },\n    // Next slide\n    next: function next() {\n      this.setSlide(this.index + 1, 'next');\n    },\n    // Pause auto rotation\n    pause: function pause(event) {\n      if (!event) {\n        this.isPaused = true;\n      }\n\n      this.clearInterval();\n    },\n    // Start auto rotate slides\n    start: function start(event) {\n      if (!event) {\n        this.isPaused = false;\n      }\n      /* istanbul ignore next: most likely will never happen, but just in case */\n\n\n      this.clearInterval(); // Don't start if no interval, or less than 2 slides\n\n      if (this.interval && this.numSlides > 1) {\n        this.$_interval = setInterval(this.next, (0, _math.mathMax)(1000, this.interval));\n      }\n    },\n    // Restart auto rotate slides when focus/hover leaves the carousel\n\n    /* istanbul ignore next */\n    restart: function restart() {\n      if (!this.$el.contains((0, _dom.getActiveElement)())) {\n        this.start();\n      }\n    },\n    doSlide: function doSlide(to, from) {\n      var _this2 = this;\n\n      var isCycling = Boolean(this.interval); // Determine sliding direction\n\n      var direction = this.calcDirection(this.direction, from, to);\n      var overlayClass = direction.overlayClass;\n      var dirClass = direction.dirClass; // Determine current and next slides\n\n      var currentSlide = this.slides[from];\n      var nextSlide = this.slides[to]; // Don't do anything if there aren't any slides to slide to\n\n      if (!currentSlide || !nextSlide) {\n        /* istanbul ignore next */\n        return;\n      } // Start animating\n\n\n      this.isSliding = true;\n\n      if (isCycling) {\n        this.pause(false);\n      }\n\n      this.$emit(_events.EVENT_NAME_SLIDING_START, to); // Update v-model\n\n      this.$emit(MODEL_EVENT_NAME, this.index);\n\n      if (this.noAnimation) {\n        (0, _dom.addClass)(nextSlide, 'active');\n        (0, _dom.removeClass)(currentSlide, 'active');\n        this.isSliding = false; // Notify ourselves that we're done sliding (slid)\n\n        this.$nextTick(function () {\n          return _this2.$emit(_events.EVENT_NAME_SLIDING_END, to);\n        });\n      } else {\n        (0, _dom.addClass)(nextSlide, overlayClass); // Trigger a reflow of next slide\n\n        (0, _dom.reflow)(nextSlide);\n        (0, _dom.addClass)(currentSlide, dirClass);\n        (0, _dom.addClass)(nextSlide, dirClass); // Transition End handler\n\n        var called = false;\n        /* istanbul ignore next: difficult to test */\n\n        var onceTransEnd = function onceTransEnd() {\n          if (called) {\n            return;\n          }\n\n          called = true;\n          /* istanbul ignore if: transition events cant be tested in JSDOM */\n\n          if (_this2.transitionEndEvent) {\n            var events = _this2.transitionEndEvent.split(/\\s+/);\n\n            events.forEach(function (event) {\n              return (0, _events2.eventOff)(nextSlide, event, onceTransEnd, _events.EVENT_OPTIONS_NO_CAPTURE);\n            });\n          }\n\n          _this2.clearAnimationTimeout();\n\n          (0, _dom.removeClass)(nextSlide, dirClass);\n          (0, _dom.removeClass)(nextSlide, overlayClass);\n          (0, _dom.addClass)(nextSlide, 'active');\n          (0, _dom.removeClass)(currentSlide, 'active');\n          (0, _dom.removeClass)(currentSlide, dirClass);\n          (0, _dom.removeClass)(currentSlide, overlayClass);\n          (0, _dom.setAttr)(currentSlide, 'aria-current', 'false');\n          (0, _dom.setAttr)(nextSlide, 'aria-current', 'true');\n          (0, _dom.setAttr)(currentSlide, 'aria-hidden', 'true');\n          (0, _dom.setAttr)(nextSlide, 'aria-hidden', 'false');\n          _this2.isSliding = false;\n          _this2.direction = null; // Notify ourselves that we're done sliding (slid)\n\n          _this2.$nextTick(function () {\n            return _this2.$emit(_events.EVENT_NAME_SLIDING_END, to);\n          });\n        }; // Set up transitionend handler\n\n        /* istanbul ignore if: transition events cant be tested in JSDOM */\n\n\n        if (this.transitionEndEvent) {\n          var events = this.transitionEndEvent.split(/\\s+/);\n          events.forEach(function (event) {\n            return (0, _events2.eventOn)(nextSlide, event, onceTransEnd, _events.EVENT_OPTIONS_NO_CAPTURE);\n          });\n        } // Fallback to setTimeout()\n\n\n        this.$_animationTimeout = setTimeout(onceTransEnd, TRANS_DURATION);\n      }\n\n      if (isCycling) {\n        this.start(false);\n      }\n    },\n    // Update slide list\n    updateSlides: function updateSlides() {\n      this.pause(true); // Get all slides as DOM elements\n\n      this.slides = (0, _dom.selectAll)('.carousel-item', this.$refs.inner);\n      var numSlides = this.slides.length; // Keep slide number in range\n\n      var index = (0, _math.mathMax)(0, (0, _math.mathMin)((0, _math.mathFloor)(this.index), numSlides - 1));\n      this.slides.forEach(function (slide, idx) {\n        var n = idx + 1;\n\n        if (idx === index) {\n          (0, _dom.addClass)(slide, 'active');\n          (0, _dom.setAttr)(slide, 'aria-current', 'true');\n        } else {\n          (0, _dom.removeClass)(slide, 'active');\n          (0, _dom.setAttr)(slide, 'aria-current', 'false');\n        }\n\n        (0, _dom.setAttr)(slide, 'aria-posinset', String(n));\n        (0, _dom.setAttr)(slide, 'aria-setsize', String(numSlides));\n      }); // Set slide as active\n\n      this.setSlide(index);\n      this.start(this.isPaused);\n    },\n    calcDirection: function calcDirection() {\n      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var curIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var nextIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      if (!direction) {\n        return nextIndex > curIndex ? DIRECTION.next : DIRECTION.prev;\n      }\n\n      return DIRECTION[direction];\n    },\n    handleClick: function handleClick(event, fn) {\n      var keyCode = event.keyCode;\n\n      if (event.type === 'click' || keyCode === _keyCodes.CODE_SPACE || keyCode === _keyCodes.CODE_ENTER) {\n        (0, _events2.stopEvent)(event);\n        fn();\n      }\n    },\n\n    /* istanbul ignore next: JSDOM doesn't support touch events */\n    handleSwipe: function handleSwipe() {\n      var absDeltaX = (0, _math.mathAbs)(this.touchDeltaX);\n\n      if (absDeltaX <= SWIPE_THRESHOLD) {\n        return;\n      }\n\n      var direction = absDeltaX / this.touchDeltaX; // Reset touch delta X\n      // https://github.com/twbs/bootstrap/pull/28558\n\n      this.touchDeltaX = 0;\n\n      if (direction > 0) {\n        // Swipe left\n        this.prev();\n      } else if (direction < 0) {\n        // Swipe right\n        this.next();\n      }\n    },\n\n    /* istanbul ignore next: JSDOM doesn't support touch events */\n    touchStart: function touchStart(event) {\n      if (_env.HAS_POINTER_EVENT_SUPPORT && PointerType[event.pointerType.toUpperCase()]) {\n        this.touchStartX = event.clientX;\n      } else if (!_env.HAS_POINTER_EVENT_SUPPORT) {\n        this.touchStartX = event.touches[0].clientX;\n      }\n    },\n\n    /* istanbul ignore next: JSDOM doesn't support touch events */\n    touchMove: function touchMove(event) {\n      // Ensure swiping with one touch and not pinching\n      if (event.touches && event.touches.length > 1) {\n        this.touchDeltaX = 0;\n      } else {\n        this.touchDeltaX = event.touches[0].clientX - this.touchStartX;\n      }\n    },\n\n    /* istanbul ignore next: JSDOM doesn't support touch events */\n    touchEnd: function touchEnd(event) {\n      if (_env.HAS_POINTER_EVENT_SUPPORT && PointerType[event.pointerType.toUpperCase()]) {\n        this.touchDeltaX = event.clientX - this.touchStartX;\n      }\n\n      this.handleSwipe(); // If it's a touch-enabled device, mouseenter/leave are fired as\n      // part of the mouse compatibility events on first tap - the carousel\n      // would stop cycling until user tapped out of it;\n      // here, we listen for touchend, explicitly pause the carousel\n      // (as if it's the second time we tap on it, mouseenter compat event\n      // is NOT fired) and after a timeout (to allow for mouse compatibility\n      // events to fire) we explicitly restart cycling\n\n      this.pause(false);\n      this.clearTouchTimeout();\n      this.$_touchTimeout = setTimeout(this.start, TOUCH_EVENT_COMPAT_WAIT + (0, _math.mathMax)(1000, this.interval));\n    }\n  },\n  render: function render(h) {\n    var _this3 = this;\n\n    var indicators = this.indicators,\n        background = this.background,\n        noAnimation = this.noAnimation,\n        noHoverPause = this.noHoverPause,\n        noTouch = this.noTouch,\n        index = this.index,\n        isSliding = this.isSliding,\n        pause = this.pause,\n        restart = this.restart,\n        touchStart = this.touchStart,\n        touchEnd = this.touchEnd;\n    var idInner = this.safeId('__BV_inner_'); // Wrapper for slides\n\n    var $inner = h('div', {\n      staticClass: 'carousel-inner',\n      attrs: {\n        id: idInner,\n        role: 'list'\n      },\n      ref: 'inner'\n    }, [this.normalizeSlot()]); // Prev and next controls\n\n    var $controls = h();\n\n    if (this.controls) {\n      var makeControl = function makeControl(direction, label, handler) {\n        var handlerWrapper = function handlerWrapper(event) {\n          /* istanbul ignore next */\n          if (!isSliding) {\n            _this3.handleClick(event, handler);\n          } else {\n            (0, _events2.stopEvent)(event, {\n              propagation: false\n            });\n          }\n        };\n\n        return h('a', {\n          staticClass: \"carousel-control-\".concat(direction),\n          attrs: {\n            href: '#',\n            role: 'button',\n            'aria-controls': idInner,\n            'aria-disabled': isSliding ? 'true' : null\n          },\n          on: {\n            click: handlerWrapper,\n            keydown: handlerWrapper\n          }\n        }, [h('span', {\n          staticClass: \"carousel-control-\".concat(direction, \"-icon\"),\n          attrs: {\n            'aria-hidden': 'true'\n          }\n        }), h('span', {\n          class: 'sr-only'\n        }, [label])]);\n      };\n\n      $controls = [makeControl('prev', this.labelPrev, this.prev), makeControl('next', this.labelNext, this.next)];\n    } // Indicators\n\n\n    var $indicators = h('ol', {\n      staticClass: 'carousel-indicators',\n      directives: [{\n        name: 'show',\n        value: indicators\n      }],\n      attrs: {\n        id: this.safeId('__BV_indicators_'),\n        'aria-hidden': indicators ? 'false' : 'true',\n        'aria-label': this.labelIndicators,\n        'aria-owns': idInner\n      }\n    }, this.slides.map(function (slide, i) {\n      var handler = function handler(event) {\n        _this3.handleClick(event, function () {\n          _this3.setSlide(i);\n        });\n      };\n\n      return h('li', {\n        class: {\n          active: i === index\n        },\n        attrs: {\n          role: 'button',\n          id: _this3.safeId(\"__BV_indicator_\".concat(i + 1, \"_\")),\n          tabindex: indicators ? '0' : '-1',\n          'aria-current': i === index ? 'true' : 'false',\n          'aria-label': \"\".concat(_this3.labelGotoSlide, \" \").concat(i + 1),\n          'aria-describedby': slide.id || null,\n          'aria-controls': idInner\n        },\n        on: {\n          click: handler,\n          keydown: handler\n        },\n        key: \"slide_\".concat(i)\n      });\n    }));\n    var on = {\n      mouseenter: noHoverPause ? _noop.noop : pause,\n      mouseleave: noHoverPause ? _noop.noop : restart,\n      focusin: pause,\n      focusout: restart,\n      keydown: function keydown(event) {\n        /* istanbul ignore next */\n        if (/input|textarea/i.test(event.target.tagName)) {\n          return;\n        }\n\n        var keyCode = event.keyCode;\n\n        if (keyCode === _keyCodes.CODE_LEFT || keyCode === _keyCodes.CODE_RIGHT) {\n          (0, _events2.stopEvent)(event);\n\n          _this3[keyCode === _keyCodes.CODE_LEFT ? 'prev' : 'next']();\n        }\n      }\n    }; // Touch support event handlers for environment\n\n    if (_env.HAS_TOUCH_SUPPORT && !noTouch) {\n      // Attach appropriate listeners (prepend event name with '&' for passive mode)\n\n      /* istanbul ignore next: JSDOM doesn't support touch events */\n      if (_env.HAS_POINTER_EVENT_SUPPORT) {\n        on['&pointerdown'] = touchStart;\n        on['&pointerup'] = touchEnd;\n      } else {\n        on['&touchstart'] = touchStart;\n        on['&touchmove'] = this.touchMove;\n        on['&touchend'] = touchEnd;\n      }\n    } // Return the carousel\n\n\n    return h('div', {\n      staticClass: 'carousel',\n      class: {\n        slide: !noAnimation,\n        'carousel-fade': !noAnimation && this.fade,\n        'pointer-event': _env.HAS_TOUCH_SUPPORT && _env.HAS_POINTER_EVENT_SUPPORT && !noTouch\n      },\n      style: {\n        background: background\n      },\n      attrs: {\n        role: 'region',\n        id: this.safeId(),\n        'aria-busy': isSliding ? 'true' : 'false'\n      },\n      on: on\n    }, [$inner, $controls, $indicators]);\n  }\n});\n\nexports.BCarousel = BCarousel;"},"sourceMaps":null,"error":null,"hash":"45a48cb6e28c0a810f507a812d218d2b","cacheData":{"env":{}}}