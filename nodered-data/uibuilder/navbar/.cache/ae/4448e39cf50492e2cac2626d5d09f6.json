{"id":"../node_modules/bootstrap-vue/esm/mixins/form-text.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"../vue","loc":{"line":7,"column":20,"index":1110},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-text.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/vue.js"},{"name":"../constants/events","loc":{"line":8,"column":120,"index":1240},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-text.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/events.js"},{"name":"../constants/props","loc":{"line":9,"column":123,"index":1386},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-text.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/props.js"},{"name":"../utils/dom","loc":{"line":10,"column":42,"index":1450},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-text.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/dom.js"},{"name":"../utils/events","loc":{"line":11,"column":26,"index":1492},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-text.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/events.js"},{"name":"../utils/math","loc":{"line":12,"column":24,"index":1535},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-text.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/math.js"},{"name":"../utils/model","loc":{"line":13,"column":31,"index":1583},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-text.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/model.js"},{"name":"../utils/number","loc":{"line":14,"column":35,"index":1636},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-text.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/number.js"},{"name":"../utils/object","loc":{"line":15,"column":25,"index":1680},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-text.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/object.js"},{"name":"../utils/props","loc":{"line":16,"column":65,"index":1764},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-text.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js"},{"name":"../utils/string","loc":{"line":17,"column":25,"index":1807},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-text.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/string.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.props = exports.formTextMixin = exports.MODEL_PROP_NAME = exports.MODEL_EVENT_NAME = void 0;\n\nvar _vue = require(\"../vue\");\n\nvar _events = require(\"../constants/events\");\n\nvar _props = require(\"../constants/props\");\n\nvar _dom = require(\"../utils/dom\");\n\nvar _events2 = require(\"../utils/events\");\n\nvar _math = require(\"../utils/math\");\n\nvar _model = require(\"../utils/model\");\n\nvar _number = require(\"../utils/number\");\n\nvar _object = require(\"../utils/object\");\n\nvar _props2 = require(\"../utils/props\");\n\nvar _string = require(\"../utils/string\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n// --- Constants ---\nvar _makeModelMixin = (0, _model.makeModelMixin)('value', {\n  type: _props.PROP_TYPE_NUMBER_STRING,\n  defaultValue: '',\n  event: _events.EVENT_NAME_UPDATE\n}),\n    modelMixin = _makeModelMixin.mixin,\n    modelProps = _makeModelMixin.props,\n    MODEL_PROP_NAME = _makeModelMixin.prop,\n    MODEL_EVENT_NAME = _makeModelMixin.event;\n\nexports.MODEL_EVENT_NAME = MODEL_EVENT_NAME;\nexports.MODEL_PROP_NAME = MODEL_PROP_NAME;\n// --- Props ---\nvar props = (0, _props2.makePropsConfigurable)((0, _object.sortKeys)(_objectSpread(_objectSpread({}, modelProps), {}, {\n  ariaInvalid: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN_STRING, false),\n  autocomplete: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n  // Debounce timeout (in ms). Not applicable with `lazy` prop\n  debounce: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING, 0),\n  formatter: (0, _props2.makeProp)(_props.PROP_TYPE_FUNCTION),\n  // Only update the `v-model` on blur/change events\n  lazy: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  lazyFormatter: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  number: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  placeholder: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n  plaintext: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  readonly: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  trim: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false)\n})), 'formTextControls'); // --- Mixin ---\n// @vue/component\n\nexports.props = props;\n\nvar formTextMixin = _vue.Vue.extend({\n  mixins: [modelMixin],\n  props: props,\n  data: function data() {\n    var value = this[MODEL_PROP_NAME];\n    return {\n      localValue: (0, _string.toString)(value),\n      vModelValue: this.modifyValue(value)\n    };\n  },\n  computed: {\n    computedClass: function computedClass() {\n      var plaintext = this.plaintext,\n          type = this.type;\n      var isRange = type === 'range';\n      var isColor = type === 'color';\n      return [{\n        // Range input needs class `custom-range`\n        'custom-range': isRange,\n        // `plaintext` not supported by `type=\"range\"` or `type=\"color\"`\n        'form-control-plaintext': plaintext && !isRange && !isColor,\n        // `form-control` not used by `type=\"range\"` or `plaintext`\n        // Always used by `type=\"color\"`\n        'form-control': isColor || !plaintext && !isRange\n      }, this.sizeFormClass, this.stateClass];\n    },\n    computedDebounce: function computedDebounce() {\n      // Ensure we have a positive number equal to or greater than 0\n      return (0, _math.mathMax)((0, _number.toInteger)(this.debounce, 0), 0);\n    },\n    hasFormatter: function hasFormatter() {\n      return (0, _props2.hasPropFunction)(this.formatter);\n    }\n  },\n  watch: _defineProperty({}, MODEL_PROP_NAME, function (newValue) {\n    var stringifyValue = (0, _string.toString)(newValue);\n    var modifiedValue = this.modifyValue(newValue);\n\n    if (stringifyValue !== this.localValue || modifiedValue !== this.vModelValue) {\n      // Clear any pending debounce timeout, as we are overwriting the user input\n      this.clearDebounce(); // Update the local values\n\n      this.localValue = stringifyValue;\n      this.vModelValue = modifiedValue;\n    }\n  }),\n  created: function created() {\n    // Create private non-reactive props\n    this.$_inputDebounceTimer = null;\n  },\n  mounted: function mounted() {\n    // Set up destroy handler\n    this.$on(_events.HOOK_EVENT_NAME_BEFORE_DESTROY, this.clearDebounce);\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.clearDebounce();\n  },\n  methods: {\n    clearDebounce: function clearDebounce() {\n      clearTimeout(this.$_inputDebounceTimer);\n      this.$_inputDebounceTimer = null;\n    },\n    formatValue: function formatValue(value, event) {\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      value = (0, _string.toString)(value);\n\n      if (this.hasFormatter && (!this.lazyFormatter || force)) {\n        value = this.formatter(value, event);\n      }\n\n      return value;\n    },\n    modifyValue: function modifyValue(value) {\n      value = (0, _string.toString)(value); // Emulate `.trim` modifier behaviour\n\n      if (this.trim) {\n        value = value.trim();\n      } // Emulate `.number` modifier behaviour\n\n\n      if (this.number) {\n        value = (0, _number.toFloat)(value, value);\n      }\n\n      return value;\n    },\n    updateValue: function updateValue(value) {\n      var _this = this;\n\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var lazy = this.lazy;\n\n      if (lazy && !force) {\n        return;\n      } // Make sure to always clear the debounce when `updateValue()`\n      // is called, even when the v-model hasn't changed\n\n\n      this.clearDebounce(); // Define the shared update logic in a method to be able to use\n      // it for immediate and debounced value changes\n\n      var doUpdate = function doUpdate() {\n        value = _this.modifyValue(value);\n\n        if (value !== _this.vModelValue) {\n          _this.vModelValue = value;\n\n          _this.$emit(MODEL_EVENT_NAME, value);\n        } else if (_this.hasFormatter) {\n          // When the `vModelValue` hasn't changed but the actual input value\n          // is out of sync, make sure to change it to the given one\n          // Usually caused by browser autocomplete and how it triggers the\n          // change or input event, or depending on the formatter function\n          // https://github.com/bootstrap-vue/bootstrap-vue/issues/2657\n          // https://github.com/bootstrap-vue/bootstrap-vue/issues/3498\n\n          /* istanbul ignore next: hard to test */\n          var $input = _this.$refs.input;\n          /* istanbul ignore if: hard to test out of sync value */\n\n          if ($input && value !== $input.value) {\n            $input.value = value;\n          }\n        }\n      }; // Only debounce the value update when a value greater than `0`\n      // is set and we are not in lazy mode or this is a forced update\n\n\n      var debounce = this.computedDebounce;\n\n      if (debounce > 0 && !lazy && !force) {\n        this.$_inputDebounceTimer = setTimeout(doUpdate, debounce);\n      } else {\n        // Immediately update the v-model\n        doUpdate();\n      }\n    },\n    onInput: function onInput(event) {\n      // `event.target.composing` is set by Vue\n      // https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/directives/model.js\n      // TODO: Is this needed now with the latest Vue?\n\n      /* istanbul ignore if: hard to test composition events */\n      if (event.target.composing) {\n        return;\n      }\n\n      var value = event.target.value;\n      var formattedValue = this.formatValue(value, event); // Exit when the `formatter` function strictly returned `false`\n      // or prevented the input event\n\n      /* istanbul ignore next */\n\n      if (formattedValue === false || event.defaultPrevented) {\n        (0, _events2.stopEvent)(event, {\n          propagation: false\n        });\n        return;\n      }\n\n      this.localValue = formattedValue;\n      this.updateValue(formattedValue);\n      this.$emit(_events.EVENT_NAME_INPUT, formattedValue);\n    },\n    onChange: function onChange(event) {\n      var value = event.target.value;\n      var formattedValue = this.formatValue(value, event); // Exit when the `formatter` function strictly returned `false`\n      // or prevented the input event\n\n      /* istanbul ignore next */\n\n      if (formattedValue === false || event.defaultPrevented) {\n        (0, _events2.stopEvent)(event, {\n          propagation: false\n        });\n        return;\n      }\n\n      this.localValue = formattedValue;\n      this.updateValue(formattedValue, true);\n      this.$emit(_events.EVENT_NAME_CHANGE, formattedValue);\n    },\n    onBlur: function onBlur(event) {\n      // Apply the `localValue` on blur to prevent cursor jumps\n      // on mobile browsers (e.g. caused by autocomplete)\n      var value = event.target.value;\n      var formattedValue = this.formatValue(value, event, true);\n\n      if (formattedValue !== false) {\n        // We need to use the modified value here to apply the\n        // `.trim` and `.number` modifiers properly\n        this.localValue = (0, _string.toString)(this.modifyValue(formattedValue)); // We pass the formatted value here since the `updateValue` method\n        // handles the modifiers itself\n\n        this.updateValue(formattedValue, true);\n      } // Emit native blur event\n\n\n      this.$emit(_events.EVENT_NAME_BLUR, event);\n    },\n    focus: function focus() {\n      // For external handler that may want a focus method\n      if (!this.disabled) {\n        (0, _dom.attemptFocus)(this.$el);\n      }\n    },\n    blur: function blur() {\n      // For external handler that may want a blur method\n      if (!this.disabled) {\n        (0, _dom.attemptBlur)(this.$el);\n      }\n    }\n  }\n});\n\nexports.formTextMixin = formTextMixin;"},"sourceMaps":null,"error":null,"hash":"cd0fbc5eb3997252fbb53c3d0510a390","cacheData":{"env":{}}}