{"id":"../node_modules/bootstrap-vue/esm/components/tooltip/helpers/bv-popper.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"popper.js","loc":{"line":7,"column":19,"index":238},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tooltip/helpers/bv-popper.js","resolved":"/data/uibuilder/navbar/node_modules/popper.js/dist/esm/popper.js"},{"name":"../../../vue","loc":{"line":8,"column":20,"index":271},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tooltip/helpers/bv-popper.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/vue.js"},{"name":"../../../constants/components","loc":{"line":9,"column":28,"index":315},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tooltip/helpers/bv-popper.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/components.js"},{"name":"../../../constants/events","loc":{"line":10,"column":113,"index":461},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tooltip/helpers/bv-popper.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/events.js"},{"name":"../../../constants/props","loc":{"line":11,"column":82,"index":572},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tooltip/helpers/bv-popper.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/props.js"},{"name":"../../../constants/safe-types","loc":{"line":12,"column":40,"index":640},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tooltip/helpers/bv-popper.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/safe-types.js"},{"name":"../../../utils/dom","loc":{"line":13,"column":41,"index":714},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tooltip/helpers/bv-popper.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/dom.js"},{"name":"../../../utils/number","loc":{"line":14,"column":24,"index":760},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tooltip/helpers/bv-popper.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/number.js"},{"name":"../../../utils/props","loc":{"line":15,"column":25,"index":810},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tooltip/helpers/bv-popper.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js"},{"name":"../../transition/bv-transition","loc":{"line":16,"column":29,"index":863},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tooltip/helpers/bv-popper.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/transition/bv-transition.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.props = exports.BVPopper = void 0;\n\nvar _popper = _interopRequireDefault(require(\"popper.js\"));\n\nvar _vue = require(\"../../../vue\");\n\nvar _components = require(\"../../../constants/components\");\n\nvar _events = require(\"../../../constants/events\");\n\nvar _props = require(\"../../../constants/props\");\n\nvar _safeTypes = require(\"../../../constants/safe-types\");\n\nvar _dom = require(\"../../../utils/dom\");\n\nvar _number = require(\"../../../utils/number\");\n\nvar _props2 = require(\"../../../utils/props\");\n\nvar _bvTransition = require(\"../../transition/bv-transition\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Base on-demand component for tooltip / popover templates\n//\n// Currently:\n//   Responsible for positioning and transitioning the template\n//   Templates are only instantiated when shown, and destroyed when hidden\n//\n// --- Constants ---\nvar AttachmentMap = {\n  AUTO: 'auto',\n  TOP: 'top',\n  RIGHT: 'right',\n  BOTTOM: 'bottom',\n  LEFT: 'left',\n  TOPLEFT: 'top',\n  TOPRIGHT: 'top',\n  RIGHTTOP: 'right',\n  RIGHTBOTTOM: 'right',\n  BOTTOMLEFT: 'bottom',\n  BOTTOMRIGHT: 'bottom',\n  LEFTTOP: 'left',\n  LEFTBOTTOM: 'left'\n};\nvar OffsetMap = {\n  AUTO: 0,\n  TOPLEFT: -1,\n  TOP: 0,\n  TOPRIGHT: +1,\n  RIGHTTOP: -1,\n  RIGHT: 0,\n  RIGHTBOTTOM: +1,\n  BOTTOMLEFT: -1,\n  BOTTOM: 0,\n  BOTTOMRIGHT: +1,\n  LEFTTOP: -1,\n  LEFT: 0,\n  LEFTBOTTOM: +1\n}; // --- Props ---\n\nvar props = {\n  // The minimum distance (in `px`) from the edge of the\n  // tooltip/popover that the arrow can be positioned\n  arrowPadding: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING, 6),\n  // 'scrollParent', 'viewport', 'window', or `Element`\n  boundary: (0, _props2.makeProp)([_safeTypes.HTMLElement, _props.PROP_TYPE_STRING], 'scrollParent'),\n  // Tooltip/popover will try and stay away from\n  // boundary edge by this many pixels\n  boundaryPadding: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING, 5),\n  fallbackPlacement: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_STRING, 'flip'),\n  offset: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING, 0),\n  placement: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'top'),\n  // Element that the tooltip/popover is positioned relative to\n  target: (0, _props2.makeProp)([_safeTypes.HTMLElement, _safeTypes.SVGElement])\n}; // --- Main component ---\n// @vue/component\n\nexports.props = props;\n\nvar BVPopper = /*#__PURE__*/_vue.Vue.extend({\n  name: _components.NAME_POPPER,\n  props: props,\n  data: function data() {\n    return {\n      // reactive props set by parent\n      noFade: false,\n      // State related data\n      localShow: true,\n      attachment: this.getAttachment(this.placement)\n    };\n  },\n  computed: {\n    /* istanbul ignore next */\n    templateType: function templateType() {\n      // Overridden by template component\n      return 'unknown';\n    },\n    popperConfig: function popperConfig() {\n      var _this = this;\n\n      var placement = this.placement;\n      return {\n        placement: this.getAttachment(placement),\n        modifiers: {\n          offset: {\n            offset: this.getOffset(placement)\n          },\n          flip: {\n            behavior: this.fallbackPlacement\n          },\n          // `arrow.element` can also be a reference to an HTML Element\n          // maybe we should make this a `$ref` in the templates?\n          arrow: {\n            element: '.arrow'\n          },\n          preventOverflow: {\n            padding: this.boundaryPadding,\n            boundariesElement: this.boundary\n          }\n        },\n        onCreate: function onCreate(data) {\n          // Handle flipping arrow classes\n          if (data.originalPlacement !== data.placement) {\n            /* istanbul ignore next: can't test in JSDOM */\n            _this.popperPlacementChange(data);\n          }\n        },\n        onUpdate: function onUpdate(data) {\n          // Handle flipping arrow classes\n          _this.popperPlacementChange(data);\n        }\n      };\n    }\n  },\n  created: function created() {\n    var _this2 = this; // Note: We are created on-demand, and should be guaranteed that\n    // DOM is rendered/ready by the time the created hook runs\n\n\n    this.$_popper = null; // Ensure we show as we mount\n\n    this.localShow = true; // Create popper instance before shown\n\n    this.$on(_events.EVENT_NAME_SHOW, function (el) {\n      _this2.popperCreate(el);\n    }); // Self destruct handler\n\n    var handleDestroy = function handleDestroy() {\n      _this2.$nextTick(function () {\n        // In a `requestAF()` to release control back to application\n        (0, _dom.requestAF)(function () {\n          _this2.$destroy();\n        });\n      });\n    }; // Self destruct if parent destroyed\n\n\n    this.$parent.$once(_events.HOOK_EVENT_NAME_DESTROYED, handleDestroy); // Self destruct after hidden\n\n    this.$once(_events.EVENT_NAME_HIDDEN, handleDestroy);\n  },\n  beforeMount: function beforeMount() {\n    // Ensure that the attachment position is correct before mounting\n    // as our propsData is added after `new Template({...})`\n    this.attachment = this.getAttachment(this.placement);\n  },\n  updated: function updated() {\n    // Update popper if needed\n    // TODO: Should this be a watcher on `this.popperConfig` instead?\n    this.updatePopper();\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.destroyPopper();\n  },\n  destroyed: function destroyed() {\n    // Make sure template is removed from DOM\n    var el = this.$el;\n    el && el.parentNode && el.parentNode.removeChild(el);\n  },\n  methods: {\n    // \"Public\" method to trigger hide template\n    hide: function hide() {\n      this.localShow = false;\n    },\n    // Private\n    getAttachment: function getAttachment(placement) {\n      return AttachmentMap[String(placement).toUpperCase()] || 'auto';\n    },\n    getOffset: function getOffset(placement) {\n      if (!this.offset) {\n        // Could set a ref for the arrow element\n        var arrow = this.$refs.arrow || (0, _dom.select)('.arrow', this.$el);\n        var arrowOffset = (0, _number.toFloat)((0, _dom.getCS)(arrow).width, 0) + (0, _number.toFloat)(this.arrowPadding, 0);\n\n        switch (OffsetMap[String(placement).toUpperCase()] || 0) {\n          /* istanbul ignore next: can't test in JSDOM */\n          case +1:\n            /* istanbul ignore next: can't test in JSDOM */\n            return \"+50%p - \".concat(arrowOffset, \"px\");\n\n          /* istanbul ignore next: can't test in JSDOM */\n\n          case -1:\n            /* istanbul ignore next: can't test in JSDOM */\n            return \"-50%p + \".concat(arrowOffset, \"px\");\n\n          default:\n            return 0;\n        }\n      }\n      /* istanbul ignore next */\n\n\n      return this.offset;\n    },\n    popperCreate: function popperCreate(el) {\n      this.destroyPopper(); // We use `el` rather than `this.$el` just in case the original\n      // mountpoint root element type was changed by the template\n\n      this.$_popper = new _popper.default(this.target, el, this.popperConfig);\n    },\n    destroyPopper: function destroyPopper() {\n      this.$_popper && this.$_popper.destroy();\n      this.$_popper = null;\n    },\n    updatePopper: function updatePopper() {\n      this.$_popper && this.$_popper.scheduleUpdate();\n    },\n    popperPlacementChange: function popperPlacementChange(data) {\n      // Callback used by popper to adjust the arrow placement\n      this.attachment = this.getAttachment(data.placement);\n    },\n\n    /* istanbul ignore next */\n    renderTemplate: function renderTemplate(h) {\n      // Will be overridden by templates\n      return h('div');\n    }\n  },\n  render: function render(h) {\n    var _this3 = this;\n\n    var noFade = this.noFade; // Note: 'show' and 'fade' classes are only appled during transition\n\n    return h(_bvTransition.BVTransition, {\n      // Transitions as soon as mounted\n      props: {\n        appear: true,\n        noFade: noFade\n      },\n      on: {\n        // Events used by parent component/instance\n        beforeEnter: function beforeEnter(el) {\n          return _this3.$emit(_events.EVENT_NAME_SHOW, el);\n        },\n        afterEnter: function afterEnter(el) {\n          return _this3.$emit(_events.EVENT_NAME_SHOWN, el);\n        },\n        beforeLeave: function beforeLeave(el) {\n          return _this3.$emit(_events.EVENT_NAME_HIDE, el);\n        },\n        afterLeave: function afterLeave(el) {\n          return _this3.$emit(_events.EVENT_NAME_HIDDEN, el);\n        }\n      }\n    }, [this.localShow ? this.renderTemplate(h) : h()]);\n  }\n});\n\nexports.BVPopper = BVPopper;"},"sourceMaps":null,"error":null,"hash":"7141aeb5f5d51587c05990849ad2ad94","cacheData":{"env":{}}}