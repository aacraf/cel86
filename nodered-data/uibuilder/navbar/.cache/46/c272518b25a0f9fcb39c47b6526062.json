{"id":"../node_modules/bootstrap-vue/esm/components/tabs/tabs.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"../../vue","loc":{"line":9,"column":39,"index":1142},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/vue.js"},{"name":"../../constants/components","loc":{"line":10,"column":50,"index":1205},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/components.js"},{"name":"../../constants/env","loc":{"line":11,"column":27,"index":1262},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/env.js"},{"name":"../../constants/events","loc":{"line":12,"column":147,"index":1432},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/events.js"},{"name":"../../constants/key-codes","loc":{"line":13,"column":91,"index":1549},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/key-codes.js"},{"name":"../../constants/props","loc":{"line":14,"column":101,"index":1679},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/props.js"},{"name":"../../constants/slots","loc":{"line":15,"column":91,"index":1795},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/slots.js"},{"name":"../../utils/array","loc":{"line":16,"column":30,"index":1850},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/array.js"},{"name":"../../utils/bv-event.class","loc":{"line":17,"column":24,"index":1895},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/bv-event.class.js"},{"name":"../../utils/dom","loc":{"line":18,"column":51,"index":1976},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/dom.js"},{"name":"../../utils/events","loc":{"line":19,"column":26,"index":2021},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/events.js"},{"name":"../../utils/identity","loc":{"line":20,"column":25,"index":2068},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/identity.js"},{"name":"../../utils/inspect","loc":{"line":21,"column":24,"index":2116},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/inspect.js"},{"name":"../../utils/loose-equal","loc":{"line":22,"column":27,"index":2166},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/loose-equal.js"},{"name":"../../utils/math","loc":{"line":23,"column":24,"index":2217},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/math.js"},{"name":"../../utils/model","loc":{"line":24,"column":31,"index":2268},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/model.js"},{"name":"../../utils/number","loc":{"line":25,"column":26,"index":2315},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/number.js"},{"name":"../../utils/object","loc":{"line":26,"column":31,"index":2368},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/object.js"},{"name":"../../utils/observe-dom","loc":{"line":27,"column":27,"index":2417},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/observe-dom.js"},{"name":"../../utils/props","loc":{"line":28,"column":48,"index":2492},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js"},{"name":"../../utils/stable-sort","loc":{"line":29,"column":27,"index":2540},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/stable-sort.js"},{"name":"../../mixins/id","loc":{"line":30,"column":42,"index":2609},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/id.js"},{"name":"../../mixins/normalize-slot","loc":{"line":31,"column":35,"index":2663},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/normalize-slot.js"},{"name":"../link/link","loc":{"line":32,"column":22,"index":2716},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/link/link.js"},{"name":"../nav/nav","loc":{"line":33,"column":41,"index":2773},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/tabs/tabs.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/nav/nav.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.props = exports.BTabs = void 0;\n\nvar _vue = require(\"../../vue\");\n\nvar _components = require(\"../../constants/components\");\n\nvar _env = require(\"../../constants/env\");\n\nvar _events = require(\"../../constants/events\");\n\nvar _keyCodes = require(\"../../constants/key-codes\");\n\nvar _props = require(\"../../constants/props\");\n\nvar _slots = require(\"../../constants/slots\");\n\nvar _array = require(\"../../utils/array\");\n\nvar _bvEvent = require(\"../../utils/bv-event.class\");\n\nvar _dom = require(\"../../utils/dom\");\n\nvar _events2 = require(\"../../utils/events\");\n\nvar _identity = require(\"../../utils/identity\");\n\nvar _inspect = require(\"../../utils/inspect\");\n\nvar _looseEqual = require(\"../../utils/loose-equal\");\n\nvar _math = require(\"../../utils/math\");\n\nvar _model = require(\"../../utils/model\");\n\nvar _number = require(\"../../utils/number\");\n\nvar _object = require(\"../../utils/object\");\n\nvar _observeDom = require(\"../../utils/observe-dom\");\n\nvar _props2 = require(\"../../utils/props\");\n\nvar _stableSort = require(\"../../utils/stable-sort\");\n\nvar _id = require(\"../../mixins/id\");\n\nvar _normalizeSlot = require(\"../../mixins/normalize-slot\");\n\nvar _link = require(\"../link/link\");\n\nvar _nav = require(\"../nav/nav\");\n\nvar _watch;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n// --- Constants ---\nvar _makeModelMixin = (0, _model.makeModelMixin)('value', {\n  type: _props.PROP_TYPE_NUMBER\n}),\n    modelMixin = _makeModelMixin.mixin,\n    modelProps = _makeModelMixin.props,\n    MODEL_PROP_NAME = _makeModelMixin.prop,\n    MODEL_EVENT_NAME = _makeModelMixin.event; // --- Helper methods ---\n// Filter function to filter out disabled tabs\n\n\nvar notDisabled = function notDisabled(tab) {\n  return !tab.disabled;\n}; // --- Helper components ---\n// @vue/component\n\n\nvar BVTabButton = /*#__PURE__*/_vue.Vue.extend({\n  name: _components.NAME_TAB_BUTTON_HELPER,\n  inject: {\n    bvTabs: {\n      default:\n      /* istanbul ignore next */\n      function _default() {\n        return {};\n      }\n    }\n  },\n  props: {\n    controls: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n    id: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n    noKeyNav: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n    posInSet: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER),\n    setSize: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER),\n    // Reference to the child <b-tab> instance\n    tab: (0, _props2.makeProp)(),\n    tabIndex: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER)\n  },\n  methods: {\n    focus: function focus() {\n      (0, _dom.attemptFocus)(this.$refs.link);\n    },\n    handleEvt: function handleEvt(event) {\n      /* istanbul ignore next */\n      if (this.tab.disabled) {\n        return;\n      }\n\n      var type = event.type,\n          keyCode = event.keyCode,\n          shiftKey = event.shiftKey;\n\n      if (type === 'click') {\n        (0, _events2.stopEvent)(event);\n        this.$emit(_events.EVENT_NAME_CLICK, event);\n      } else if (type === 'keydown' && keyCode === _keyCodes.CODE_SPACE) {\n        // For ARIA tabs the SPACE key will also trigger a click/select\n        // Even with keyboard navigation disabled, SPACE should \"click\" the button\n        // See: https://github.com/bootstrap-vue/bootstrap-vue/issues/4323\n        (0, _events2.stopEvent)(event);\n        this.$emit(_events.EVENT_NAME_CLICK, event);\n      } else if (type === 'keydown' && !this.noKeyNav) {\n        // For keyboard navigation\n        if ([_keyCodes.CODE_UP, _keyCodes.CODE_LEFT, _keyCodes.CODE_HOME].indexOf(keyCode) !== -1) {\n          (0, _events2.stopEvent)(event);\n\n          if (shiftKey || keyCode === _keyCodes.CODE_HOME) {\n            this.$emit(_events.EVENT_NAME_FIRST, event);\n          } else {\n            this.$emit(_events.EVENT_NAME_PREV, event);\n          }\n        } else if ([_keyCodes.CODE_DOWN, _keyCodes.CODE_RIGHT, _keyCodes.CODE_END].indexOf(keyCode) !== -1) {\n          (0, _events2.stopEvent)(event);\n\n          if (shiftKey || keyCode === _keyCodes.CODE_END) {\n            this.$emit(_events.EVENT_NAME_LAST, event);\n          } else {\n            this.$emit(_events.EVENT_NAME_NEXT, event);\n          }\n        }\n      }\n    }\n  },\n  render: function render(h) {\n    var id = this.id,\n        tabIndex = this.tabIndex,\n        setSize = this.setSize,\n        posInSet = this.posInSet,\n        controls = this.controls,\n        handleEvt = this.handleEvt;\n    var _this$tab = this.tab,\n        title = _this$tab.title,\n        localActive = _this$tab.localActive,\n        disabled = _this$tab.disabled,\n        titleItemClass = _this$tab.titleItemClass,\n        titleLinkClass = _this$tab.titleLinkClass,\n        titleLinkAttributes = _this$tab.titleLinkAttributes;\n    var $link = h(_link.BLink, {\n      staticClass: 'nav-link',\n      class: [{\n        active: localActive && !disabled,\n        disabled: disabled\n      }, titleLinkClass, // Apply <b-tabs> `activeNavItemClass` styles when the tab is active\n      localActive ? this.bvTabs.activeNavItemClass : null],\n      props: {\n        disabled: disabled\n      },\n      attrs: _objectSpread(_objectSpread({}, titleLinkAttributes), {}, {\n        id: id,\n        role: 'tab',\n        // Roving tab index when keynav enabled\n        tabindex: tabIndex,\n        'aria-selected': localActive && !disabled ? 'true' : 'false',\n        'aria-setsize': setSize,\n        'aria-posinset': posInSet,\n        'aria-controls': controls\n      }),\n      on: {\n        click: handleEvt,\n        keydown: handleEvt\n      },\n      ref: 'link'\n    }, [this.tab.normalizeSlot(_slots.SLOT_NAME_TITLE) || title]);\n    return h('li', {\n      staticClass: 'nav-item',\n      class: [titleItemClass],\n      attrs: {\n        role: 'presentation'\n      }\n    }, [$link]);\n  }\n}); // --- Props ---\n\n\nvar navProps = (0, _object.omit)(_nav.props, ['tabs', 'isNavBar', 'cardHeader']);\nvar props = (0, _props2.makePropsConfigurable)((0, _object.sortKeys)(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, _id.props), modelProps), navProps), {}, {\n  // Only applied to the currently active `<b-nav-item>`\n  activeNavItemClass: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_OBJECT_STRING),\n  // Only applied to the currently active `<b-tab>`\n  // This prop is sniffed by the `<b-tab>` child\n  activeTabClass: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_OBJECT_STRING),\n  card: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  contentClass: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_OBJECT_STRING),\n  // Synonym for 'bottom'\n  end: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // This prop is sniffed by the `<b-tab>` child\n  lazy: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  navClass: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_OBJECT_STRING),\n  navWrapperClass: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_OBJECT_STRING),\n  noFade: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  noKeyNav: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  noNavStyle: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  tag: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'div')\n})), _components.NAME_TABS); // --- Main component ---\n// @vue/component\n\nexports.props = props;\n\nvar BTabs = /*#__PURE__*/_vue.Vue.extend({\n  name: _components.NAME_TABS,\n  mixins: [_id.idMixin, modelMixin, _normalizeSlot.normalizeSlotMixin],\n  provide: function provide() {\n    return {\n      bvTabs: this\n    };\n  },\n  props: props,\n  data: function data() {\n    return {\n      // Index of current tab\n      currentTab: (0, _number.toInteger)(this[MODEL_PROP_NAME], -1),\n      // Array of direct child `<b-tab>` instances, in DOM order\n      tabs: [],\n      // Array of child instances registered (for triggering reactive updates)\n      registeredTabs: []\n    };\n  },\n  computed: {\n    fade: function fade() {\n      // This computed prop is sniffed by the tab child\n      return !this.noFade;\n    },\n    localNavClass: function localNavClass() {\n      var classes = [];\n\n      if (this.card && this.vertical) {\n        classes.push('card-header', 'h-100', 'border-bottom-0', 'rounded-0');\n      }\n\n      return [].concat(classes, [this.navClass]);\n    }\n  },\n  watch: (_watch = {}, _defineProperty(_watch, MODEL_PROP_NAME, function (newValue, oldValue) {\n    if (newValue !== oldValue) {\n      newValue = (0, _number.toInteger)(newValue, -1);\n      oldValue = (0, _number.toInteger)(oldValue, 0);\n      var $tab = this.tabs[newValue];\n\n      if ($tab && !$tab.disabled) {\n        this.activateTab($tab);\n      } else {\n        // Try next or prev tabs\n        if (newValue < oldValue) {\n          this.previousTab();\n        } else {\n          this.nextTab();\n        }\n      }\n    }\n  }), _defineProperty(_watch, \"currentTab\", function currentTab(newValue) {\n    var index = -1; // Ensure only one tab is active at most\n\n    this.tabs.forEach(function ($tab, i) {\n      if (i === newValue && !$tab.disabled) {\n        $tab.localActive = true;\n        index = i;\n      } else {\n        $tab.localActive = false;\n      }\n    }); // Update the v-model\n\n    this.$emit(MODEL_EVENT_NAME, index);\n  }), _defineProperty(_watch, \"tabs\", function tabs(newValue, oldValue) {\n    var _this = this; // We use `_uid` instead of `safeId()`, as the later is changed in a `$nextTick()`\n    // if no explicit ID is provided, causing duplicate emits\n\n\n    if (!(0, _looseEqual.looseEqual)(newValue.map(function ($tab) {\n      return $tab[_vue.COMPONENT_UID_KEY];\n    }), oldValue.map(function ($tab) {\n      return $tab[_vue.COMPONENT_UID_KEY];\n    }))) {\n      // In a `$nextTick()` to ensure `currentTab` has been set first\n      this.$nextTick(function () {\n        // We emit shallow copies of the new and old arrays of tabs,\n        // to prevent users from potentially mutating the internal arrays\n        _this.$emit(_events.EVENT_NAME_CHANGED, newValue.slice(), oldValue.slice());\n      });\n    }\n  }), _defineProperty(_watch, \"registeredTabs\", function registeredTabs() {\n    this.updateTabs();\n  }), _watch),\n  created: function created() {\n    // Create private non-reactive props\n    this.$_observer = null;\n  },\n  mounted: function mounted() {\n    this.setObserver(true);\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.setObserver(false); // Ensure no references to child instances exist\n\n    this.tabs = [];\n  },\n  methods: {\n    registerTab: function registerTab($tab) {\n      if (!(0, _array.arrayIncludes)(this.registeredTabs, $tab)) {\n        this.registeredTabs.push($tab);\n      }\n    },\n    unregisterTab: function unregisterTab($tab) {\n      this.registeredTabs = this.registeredTabs.slice().filter(function ($t) {\n        return $t !== $tab;\n      });\n    },\n    // DOM observer is needed to detect changes in order of tabs\n    setObserver: function setObserver() {\n      var _this2 = this;\n\n      var on = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.$_observer && this.$_observer.disconnect();\n      this.$_observer = null;\n\n      if (on) {\n        /* istanbul ignore next: difficult to test mutation observer in JSDOM */\n        var handler = function handler() {\n          _this2.$nextTick(function () {\n            (0, _dom.requestAF)(function () {\n              _this2.updateTabs();\n            });\n          });\n        }; // Watch for changes to `<b-tab>` sub components\n\n\n        this.$_observer = (0, _observeDom.observeDom)(this.$refs.content, handler, {\n          childList: true,\n          subtree: false,\n          attributes: true,\n          attributeFilter: ['id']\n        });\n      }\n    },\n    getTabs: function getTabs() {\n      var $tabs = this.registeredTabs.filter(function ($tab) {\n        return $tab.$children.filter(function ($t) {\n          return $t._isTab;\n        }).length === 0;\n      }); // DOM Order of Tabs\n\n      var order = [];\n      /* istanbul ignore next: too difficult to test */\n\n      if (_env.IS_BROWSER && $tabs.length > 0) {\n        // We rely on the DOM when mounted to get the \"true\" order of the `<b-tab>` children\n        // `querySelectorAll()` always returns elements in document order, regardless of\n        // order specified in the selector\n        var selector = $tabs.map(function ($tab) {\n          return \"#\".concat($tab.safeId());\n        }).join(', ');\n        order = (0, _dom.selectAll)(selector, this.$el).map(function ($el) {\n          return $el.id;\n        }).filter(_identity.identity);\n      } // Stable sort keeps the original order if not found in the `order` array,\n      // which will be an empty array before mount\n\n\n      return (0, _stableSort.stableSort)($tabs, function (a, b) {\n        return order.indexOf(a.safeId()) - order.indexOf(b.safeId());\n      });\n    },\n    updateTabs: function updateTabs() {\n      var $tabs = this.getTabs(); // Find last active non-disabled tab in current tabs\n      // We trust tab state over `currentTab`, in case tabs were added/removed/re-ordered\n\n      var tabIndex = $tabs.indexOf($tabs.slice().reverse().find(function ($tab) {\n        return $tab.localActive && !$tab.disabled;\n      })); // Else try setting to `currentTab`\n\n      if (tabIndex < 0) {\n        var currentTab = this.currentTab;\n\n        if (currentTab >= $tabs.length) {\n          // Handle last tab being removed, so find the last non-disabled tab\n          tabIndex = $tabs.indexOf($tabs.slice().reverse().find(notDisabled));\n        } else if ($tabs[currentTab] && !$tabs[currentTab].disabled) {\n          // Current tab is not disabled\n          tabIndex = currentTab;\n        }\n      } // Else find first non-disabled tab in current tabs\n\n\n      if (tabIndex < 0) {\n        tabIndex = $tabs.indexOf($tabs.find(notDisabled));\n      } // Ensure only one tab is active at a time\n\n\n      $tabs.forEach(function ($tab, index) {\n        $tab.localActive = index === tabIndex;\n      });\n      this.tabs = $tabs;\n      this.currentTab = tabIndex;\n    },\n    // Find a button that controls a tab, given the tab reference\n    // Returns the button vm instance\n    getButtonForTab: function getButtonForTab($tab) {\n      return (this.$refs.buttons || []).find(function ($btn) {\n        return $btn.tab === $tab;\n      });\n    },\n    // Force a button to re-render its content, given a `<b-tab>` instance\n    // Called by `<b-tab>` on `update()`\n    updateButton: function updateButton($tab) {\n      var $button = this.getButtonForTab($tab);\n\n      if ($button && $button.$forceUpdate) {\n        $button.$forceUpdate();\n      }\n    },\n    // Activate a tab given a `<b-tab>` instance\n    // Also accessed by `<b-tab>`\n    activateTab: function activateTab($tab) {\n      var currentTab = this.currentTab,\n          $tabs = this.tabs;\n      var result = false;\n\n      if ($tab) {\n        var index = $tabs.indexOf($tab);\n\n        if (index !== currentTab && index > -1 && !$tab.disabled) {\n          var tabEvent = new _bvEvent.BvEvent(_events.EVENT_NAME_ACTIVATE_TAB, {\n            cancelable: true,\n            vueTarget: this,\n            componentId: this.safeId()\n          });\n          this.$emit(tabEvent.type, index, currentTab, tabEvent);\n\n          if (!tabEvent.defaultPrevented) {\n            this.currentTab = index;\n            result = true;\n          }\n        }\n      } // Couldn't set tab, so ensure v-model is up to date\n\n      /* istanbul ignore next: should rarely happen */\n\n\n      if (!result && this[MODEL_PROP_NAME] !== currentTab) {\n        this.$emit(MODEL_EVENT_NAME, currentTab);\n      }\n\n      return result;\n    },\n    // Deactivate a tab given a `<b-tab>` instance\n    // Accessed by `<b-tab>`\n    deactivateTab: function deactivateTab($tab) {\n      if ($tab) {\n        // Find first non-disabled tab that isn't the one being deactivated\n        // If no tabs are available, then don't deactivate current tab\n        return this.activateTab(this.tabs.filter(function ($t) {\n          return $t !== $tab;\n        }).find(notDisabled));\n      }\n      /* istanbul ignore next: should never/rarely happen */\n\n\n      return false;\n    },\n    // Focus a tab button given its `<b-tab>` instance\n    focusButton: function focusButton($tab) {\n      var _this3 = this; // Wrap in `$nextTick()` to ensure DOM has completed rendering\n\n\n      this.$nextTick(function () {\n        (0, _dom.attemptFocus)(_this3.getButtonForTab($tab));\n      });\n    },\n    // Emit a click event on a specified `<b-tab>` component instance\n    emitTabClick: function emitTabClick(tab, event) {\n      if ((0, _inspect.isEvent)(event) && tab && tab.$emit && !tab.disabled) {\n        tab.$emit(_events.EVENT_NAME_CLICK, event);\n      }\n    },\n    // Click handler\n    clickTab: function clickTab($tab, event) {\n      this.activateTab($tab);\n      this.emitTabClick($tab, event);\n    },\n    // Move to first non-disabled tab\n    firstTab: function firstTab(focus) {\n      var $tab = this.tabs.find(notDisabled);\n\n      if (this.activateTab($tab) && focus) {\n        this.focusButton($tab);\n        this.emitTabClick($tab, focus);\n      }\n    },\n    // Move to previous non-disabled tab\n    previousTab: function previousTab(focus) {\n      var currentIndex = (0, _math.mathMax)(this.currentTab, 0);\n      var $tab = this.tabs.slice(0, currentIndex).reverse().find(notDisabled);\n\n      if (this.activateTab($tab) && focus) {\n        this.focusButton($tab);\n        this.emitTabClick($tab, focus);\n      }\n    },\n    // Move to next non-disabled tab\n    nextTab: function nextTab(focus) {\n      var currentIndex = (0, _math.mathMax)(this.currentTab, -1);\n      var $tab = this.tabs.slice(currentIndex + 1).find(notDisabled);\n\n      if (this.activateTab($tab) && focus) {\n        this.focusButton($tab);\n        this.emitTabClick($tab, focus);\n      }\n    },\n    // Move to last non-disabled tab\n    lastTab: function lastTab(focus) {\n      var $tab = this.tabs.slice().reverse().find(notDisabled);\n\n      if (this.activateTab($tab) && focus) {\n        this.focusButton($tab);\n        this.emitTabClick($tab, focus);\n      }\n    }\n  },\n  render: function render(h) {\n    var _this4 = this;\n\n    var align = this.align,\n        card = this.card,\n        end = this.end,\n        fill = this.fill,\n        firstTab = this.firstTab,\n        justified = this.justified,\n        lastTab = this.lastTab,\n        nextTab = this.nextTab,\n        noKeyNav = this.noKeyNav,\n        noNavStyle = this.noNavStyle,\n        pills = this.pills,\n        previousTab = this.previousTab,\n        small = this.small,\n        $tabs = this.tabs,\n        vertical = this.vertical; // Currently active tab\n\n    var $activeTab = $tabs.find(function ($tab) {\n      return $tab.localActive && !$tab.disabled;\n    }); // Tab button to allow focusing when no active tab found (keynav only)\n\n    var $fallbackTab = $tabs.find(function ($tab) {\n      return !$tab.disabled;\n    }); // For each `<b-tab>` found create the tab buttons\n\n    var $buttons = $tabs.map(function ($tab, index) {\n      var _on;\n\n      var safeId = $tab.safeId; // Ensure at least one tab button is focusable when keynav enabled (if possible)\n\n      var tabIndex = null;\n\n      if (!noKeyNav) {\n        // Buttons are not in tab index unless active, or a fallback tab\n        tabIndex = -1;\n\n        if ($tab === $activeTab || !$activeTab && $tab === $fallbackTab) {\n          // Place tab button in tab sequence\n          tabIndex = null;\n        }\n      }\n\n      return h(BVTabButton, {\n        props: {\n          controls: safeId ? safeId() : null,\n          id: $tab.controlledBy || (safeId ? safeId(\"_BV_tab_button_\") : null),\n          noKeyNav: noKeyNav,\n          posInSet: index + 1,\n          setSize: $tabs.length,\n          tab: $tab,\n          tabIndex: tabIndex\n        },\n        on: (_on = {}, _defineProperty(_on, _events.EVENT_NAME_CLICK, function (event) {\n          _this4.clickTab($tab, event);\n        }), _defineProperty(_on, _events.EVENT_NAME_FIRST, firstTab), _defineProperty(_on, _events.EVENT_NAME_PREV, previousTab), _defineProperty(_on, _events.EVENT_NAME_NEXT, nextTab), _defineProperty(_on, _events.EVENT_NAME_LAST, lastTab), _on),\n        key: $tab[_vue.COMPONENT_UID_KEY] || index,\n        ref: 'buttons',\n        // Needed to make `this.$refs.buttons` an array\n        refInFor: true\n      });\n    });\n    var $nav = h(_nav.BNav, {\n      class: this.localNavClass,\n      attrs: {\n        role: 'tablist',\n        id: this.safeId('_BV_tab_controls_')\n      },\n      props: {\n        fill: fill,\n        justified: justified,\n        align: align,\n        tabs: !noNavStyle && !pills,\n        pills: !noNavStyle && pills,\n        vertical: vertical,\n        small: small,\n        cardHeader: card && !vertical\n      },\n      ref: 'nav'\n    }, [this.normalizeSlot(_slots.SLOT_NAME_TABS_START) || h(), $buttons, this.normalizeSlot(_slots.SLOT_NAME_TABS_END) || h()]);\n    $nav = h('div', {\n      class: [{\n        'card-header': card && !vertical && !end,\n        'card-footer': card && !vertical && end,\n        'col-auto': vertical\n      }, this.navWrapperClass],\n      key: 'bv-tabs-nav'\n    }, [$nav]);\n    var $children = this.normalizeSlot() || [];\n    var $empty = h();\n\n    if ($children.length === 0) {\n      $empty = h('div', {\n        class: ['tab-pane', 'active', {\n          'card-body': card\n        }],\n        key: 'bv-empty-tab'\n      }, this.normalizeSlot(_slots.SLOT_NAME_EMPTY));\n    }\n\n    var $content = h('div', {\n      staticClass: 'tab-content',\n      class: [{\n        col: vertical\n      }, this.contentClass],\n      attrs: {\n        id: this.safeId('_BV_tab_container_')\n      },\n      key: 'bv-content',\n      ref: 'content'\n    }, [$children, $empty]); // Render final output\n\n    return h(this.tag, {\n      staticClass: 'tabs',\n      class: {\n        row: vertical,\n        'no-gutters': vertical && card\n      },\n      attrs: {\n        id: this.safeId()\n      }\n    }, [end ? $content : h(), $nav, end ? h() : $content]);\n  }\n});\n\nexports.BTabs = BTabs;"},"sourceMaps":null,"error":null,"hash":"0d9ee830efc01c022994a4802189aa2e","cacheData":{"env":{}}}