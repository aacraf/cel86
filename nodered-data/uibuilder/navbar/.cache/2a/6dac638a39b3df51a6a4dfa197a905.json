{"id":"../node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"../../constants/components","loc":{"line":1,"column":30,"index":30},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/components.js"},{"name":"../../constants/env","loc":{"line":2,"column":27,"index":87},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/env.js"},{"name":"../../constants/events","loc":{"line":3,"column":38,"index":148},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/events.js"},{"name":"../../constants/key-codes","loc":{"line":4,"column":39,"index":213},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/key-codes.js"},{"name":"../../constants/regex","loc":{"line":5,"column":52,"index":294},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/regex.js"},{"name":"../../utils/array","loc":{"line":6,"column":38,"index":357},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/array.js"},{"name":"../../utils/dom","loc":{"line":7,"column":130,"index":508},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/dom.js"},{"name":"../../utils/events","loc":{"line":8,"column":76,"index":603},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/events.js"},{"name":"../../utils/inspect","loc":{"line":9,"column":25,"index":650},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/inspect.js"},{"name":"../../utils/loose-equal","loc":{"line":10,"column":27,"index":700},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/loose-equal.js"},{"name":"../../utils/object","loc":{"line":11,"column":21,"index":748},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/object.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VBToggle = void 0;\n\nvar _components = require(\"../../constants/components\");\n\nvar _env = require(\"../../constants/env\");\n\nvar _events = require(\"../../constants/events\");\n\nvar _keyCodes = require(\"../../constants/key-codes\");\n\nvar _regex = require(\"../../constants/regex\");\n\nvar _array = require(\"../../utils/array\");\n\nvar _dom = require(\"../../utils/dom\");\n\nvar _events2 = require(\"../../utils/events\");\n\nvar _inspect = require(\"../../utils/inspect\");\n\nvar _looseEqual = require(\"../../utils/loose-equal\");\n\nvar _object = require(\"../../utils/object\");\n\n// --- Constants ---\n// Classes to apply to trigger element\nvar CLASS_BV_TOGGLE_COLLAPSED = 'collapsed';\nvar CLASS_BV_TOGGLE_NOT_COLLAPSED = 'not-collapsed'; // Property key for handler storage\n\nvar BV_BASE = '__BV_toggle'; // Root event listener property (Function)\n\nvar BV_TOGGLE_ROOT_HANDLER = \"\".concat(BV_BASE, \"_HANDLER__\"); // Trigger element click handler property (Function)\n\nvar BV_TOGGLE_CLICK_HANDLER = \"\".concat(BV_BASE, \"_CLICK__\"); // Target visibility state property (Boolean)\n\nvar BV_TOGGLE_STATE = \"\".concat(BV_BASE, \"_STATE__\"); // Target ID list property (Array)\n\nvar BV_TOGGLE_TARGETS = \"\".concat(BV_BASE, \"_TARGETS__\"); // Commonly used strings\n\nvar STRING_FALSE = 'false';\nvar STRING_TRUE = 'true'; // Commonly used attribute names\n\nvar ATTR_ARIA_CONTROLS = 'aria-controls';\nvar ATTR_ARIA_EXPANDED = 'aria-expanded';\nvar ATTR_ROLE = 'role';\nvar ATTR_TABINDEX = 'tabindex'; // Commonly used style properties\n\nvar STYLE_OVERFLOW_ANCHOR = 'overflow-anchor'; // Emitted control event for collapse (emitted to collapse)\n\nvar ROOT_ACTION_EVENT_NAME_TOGGLE = (0, _events2.getRootActionEventName)(_components.NAME_COLLAPSE, 'toggle'); // Listen to event for toggle state update (emitted by collapse)\n\nvar ROOT_EVENT_NAME_STATE = (0, _events2.getRootEventName)(_components.NAME_COLLAPSE, 'state'); // Private event emitted on `$root` to ensure the toggle state is always synced\n// Gets emitted even if the state of b-collapse has not changed\n// This event is NOT to be documented as people should not be using it\n\nvar ROOT_EVENT_NAME_SYNC_STATE = (0, _events2.getRootEventName)(_components.NAME_COLLAPSE, 'sync-state'); // Private event we send to collapse to request state update sync event\n\nvar ROOT_ACTION_EVENT_NAME_REQUEST_STATE = (0, _events2.getRootActionEventName)(_components.NAME_COLLAPSE, 'request-state');\nvar KEYDOWN_KEY_CODES = [_keyCodes.CODE_ENTER, _keyCodes.CODE_SPACE]; // --- Helper methods ---\n\nvar isNonStandardTag = function isNonStandardTag(el) {\n  return !(0, _array.arrayIncludes)(['button', 'a'], el.tagName.toLowerCase());\n};\n\nvar getTargets = function getTargets(_ref, el) {\n  var modifiers = _ref.modifiers,\n      arg = _ref.arg,\n      value = _ref.value; // Any modifiers are considered target IDs\n\n  var targets = (0, _object.keys)(modifiers || {}); // If value is a string, split out individual targets (if space delimited)\n\n  value = (0, _inspect.isString)(value) ? value.split(_regex.RX_SPACE_SPLIT) : value; // Support target ID as link href (`href=\"#id\"`)\n\n  if ((0, _dom.isTag)(el.tagName, 'a')) {\n    var href = (0, _dom.getAttr)(el, 'href') || '';\n\n    if (_regex.RX_HASH_ID.test(href)) {\n      targets.push(href.replace(_regex.RX_HASH, ''));\n    }\n  } // Add ID from `arg` (if provided), and support value\n  // as a single string ID or an array of string IDs\n  // If `value` is not an array or string, then it gets filtered out\n\n\n  (0, _array.concat)(arg, value).forEach(function (t) {\n    return (0, _inspect.isString)(t) && targets.push(t);\n  }); // Return only unique and truthy target IDs\n\n  return targets.filter(function (t, index, arr) {\n    return t && arr.indexOf(t) === index;\n  });\n};\n\nvar removeClickListener = function removeClickListener(el) {\n  var handler = el[BV_TOGGLE_CLICK_HANDLER];\n\n  if (handler) {\n    (0, _events2.eventOff)(el, 'click', handler, _events.EVENT_OPTIONS_PASSIVE);\n    (0, _events2.eventOff)(el, 'keydown', handler, _events.EVENT_OPTIONS_PASSIVE);\n  }\n\n  el[BV_TOGGLE_CLICK_HANDLER] = null;\n};\n\nvar addClickListener = function addClickListener(el, vnode) {\n  removeClickListener(el);\n\n  if (vnode.context) {\n    var handler = function handler(event) {\n      if (!(event.type === 'keydown' && !(0, _array.arrayIncludes)(KEYDOWN_KEY_CODES, event.keyCode)) && !(0, _dom.isDisabled)(el)) {\n        var targets = el[BV_TOGGLE_TARGETS] || [];\n        targets.forEach(function (target) {\n          vnode.context.$root.$emit(ROOT_ACTION_EVENT_NAME_TOGGLE, target);\n        });\n      }\n    };\n\n    el[BV_TOGGLE_CLICK_HANDLER] = handler;\n    (0, _events2.eventOn)(el, 'click', handler, _events.EVENT_OPTIONS_PASSIVE);\n\n    if (isNonStandardTag(el)) {\n      (0, _events2.eventOn)(el, 'keydown', handler, _events.EVENT_OPTIONS_PASSIVE);\n    }\n  }\n};\n\nvar removeRootListeners = function removeRootListeners(el, vnode) {\n  if (el[BV_TOGGLE_ROOT_HANDLER] && vnode.context) {\n    vnode.context.$root.$off([ROOT_EVENT_NAME_STATE, ROOT_EVENT_NAME_SYNC_STATE], el[BV_TOGGLE_ROOT_HANDLER]);\n  }\n\n  el[BV_TOGGLE_ROOT_HANDLER] = null;\n};\n\nvar addRootListeners = function addRootListeners(el, vnode) {\n  removeRootListeners(el, vnode);\n\n  if (vnode.context) {\n    var handler = function handler(id, state) {\n      // `state` will be `true` if target is expanded\n      if ((0, _array.arrayIncludes)(el[BV_TOGGLE_TARGETS] || [], id)) {\n        // Set/Clear 'collapsed' visibility class state\n        el[BV_TOGGLE_STATE] = state; // Set `aria-expanded` and class state on trigger element\n\n        setToggleState(el, state);\n      }\n    };\n\n    el[BV_TOGGLE_ROOT_HANDLER] = handler; // Listen for toggle state changes (public) and sync (private)\n\n    vnode.context.$root.$on([ROOT_EVENT_NAME_STATE, ROOT_EVENT_NAME_SYNC_STATE], handler);\n  }\n};\n\nvar setToggleState = function setToggleState(el, state) {\n  // State refers to the visibility of the collapse/sidebar\n  if (state) {\n    (0, _dom.removeClass)(el, CLASS_BV_TOGGLE_COLLAPSED);\n    (0, _dom.addClass)(el, CLASS_BV_TOGGLE_NOT_COLLAPSED);\n    (0, _dom.setAttr)(el, ATTR_ARIA_EXPANDED, STRING_TRUE);\n  } else {\n    (0, _dom.removeClass)(el, CLASS_BV_TOGGLE_NOT_COLLAPSED);\n    (0, _dom.addClass)(el, CLASS_BV_TOGGLE_COLLAPSED);\n    (0, _dom.setAttr)(el, ATTR_ARIA_EXPANDED, STRING_FALSE);\n  }\n}; // Reset and remove a property from the provided element\n\n\nvar resetProp = function resetProp(el, prop) {\n  el[prop] = null;\n  delete el[prop];\n}; // Handle directive updates\n\n\nvar handleUpdate = function handleUpdate(el, binding, vnode) {\n  /* istanbul ignore next: should never happen */\n  if (!_env.IS_BROWSER || !vnode.context) {\n    return;\n  } // If element is not a button or link, we add `role=\"button\"`\n  // and `tabindex=\"0\"` for accessibility reasons\n\n\n  if (isNonStandardTag(el)) {\n    if (!(0, _dom.hasAttr)(el, ATTR_ROLE)) {\n      (0, _dom.setAttr)(el, ATTR_ROLE, 'button');\n    }\n\n    if (!(0, _dom.hasAttr)(el, ATTR_TABINDEX)) {\n      (0, _dom.setAttr)(el, ATTR_TABINDEX, '0');\n    }\n  } // Ensure the collapse class and `aria-*` attributes persist\n  // after element is updated (either by parent re-rendering\n  // or changes to this element or its contents)\n\n\n  setToggleState(el, el[BV_TOGGLE_STATE]); // Parse list of target IDs\n\n  var targets = getTargets(binding, el); // Ensure the `aria-controls` hasn't been overwritten\n  // or removed when vnode updates\n  // Also ensure to set `overflow-anchor` to `none` to prevent\n  // the browser's scroll anchoring behavior\n\n  /* istanbul ignore else */\n\n  if (targets.length > 0) {\n    (0, _dom.setAttr)(el, ATTR_ARIA_CONTROLS, targets.join(' '));\n    (0, _dom.setStyle)(el, STYLE_OVERFLOW_ANCHOR, 'none');\n  } else {\n    (0, _dom.removeAttr)(el, ATTR_ARIA_CONTROLS);\n    (0, _dom.removeStyle)(el, STYLE_OVERFLOW_ANCHOR);\n  } // Add/Update our click listener(s)\n  // Wrap in a `requestAF()` to allow any previous\n  // click handling to occur first\n\n\n  (0, _dom.requestAF)(function () {\n    addClickListener(el, vnode);\n  }); // If targets array has changed, update\n\n  if (!(0, _looseEqual.looseEqual)(targets, el[BV_TOGGLE_TARGETS])) {\n    // Update targets array to element storage\n    el[BV_TOGGLE_TARGETS] = targets; // Ensure `aria-controls` is up to date\n    // Request a state update from targets so that we can\n    // ensure expanded state is correct (in most cases)\n\n    targets.forEach(function (target) {\n      vnode.context.$root.$emit(ROOT_ACTION_EVENT_NAME_REQUEST_STATE, target);\n    });\n  }\n};\n/*\n * Export our directive\n */\n\n\nvar VBToggle = {\n  bind: function bind(el, binding, vnode) {\n    // State is initially collapsed until we receive a state event\n    el[BV_TOGGLE_STATE] = false; // Assume no targets initially\n\n    el[BV_TOGGLE_TARGETS] = []; // Add our root listeners\n\n    addRootListeners(el, vnode); // Initial update of trigger\n\n    handleUpdate(el, binding, vnode);\n  },\n  componentUpdated: handleUpdate,\n  updated: handleUpdate,\n  unbind: function unbind(el, binding, vnode) {\n    removeClickListener(el); // Remove our $root listener\n\n    removeRootListeners(el, vnode); // Reset custom props\n\n    resetProp(el, BV_TOGGLE_ROOT_HANDLER);\n    resetProp(el, BV_TOGGLE_CLICK_HANDLER);\n    resetProp(el, BV_TOGGLE_STATE);\n    resetProp(el, BV_TOGGLE_TARGETS); // Reset classes/attrs/styles\n\n    (0, _dom.removeClass)(el, CLASS_BV_TOGGLE_COLLAPSED);\n    (0, _dom.removeClass)(el, CLASS_BV_TOGGLE_NOT_COLLAPSED);\n    (0, _dom.removeAttr)(el, ATTR_ARIA_EXPANDED);\n    (0, _dom.removeAttr)(el, ATTR_ARIA_CONTROLS);\n    (0, _dom.removeAttr)(el, ATTR_ROLE);\n    (0, _dom.removeStyle)(el, STYLE_OVERFLOW_ANCHOR);\n  }\n};\nexports.VBToggle = VBToggle;"},"sourceMaps":null,"error":null,"hash":"80364b16236f98a822cfab3cf68cdb29","cacheData":{"env":{}}}