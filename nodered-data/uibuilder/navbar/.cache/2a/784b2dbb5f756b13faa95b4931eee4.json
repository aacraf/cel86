{"id":"../node_modules/bootstrap-vue/esm/mixins/dropdown.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"popper.js","loc":{"line":7,"column":19,"index":1109},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/popper.js/dist/esm/popper.js"},{"name":"../vue","loc":{"line":8,"column":20,"index":1142},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/vue.js"},{"name":"../constants/components","loc":{"line":9,"column":30,"index":1182},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/components.js"},{"name":"../constants/events","loc":{"line":10,"column":123,"index":1332},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/events.js"},{"name":"../constants/key-codes","loc":{"line":11,"column":69,"index":1424},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/key-codes.js"},{"name":"../constants/popper","loc":{"line":12,"column":146,"index":1596},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/popper.js"},{"name":"../constants/props","loc":{"line":13,"column":95,"index":1714},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/props.js"},{"name":"../constants/safe-types","loc":{"line":14,"column":28,"index":1764},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/safe-types.js"},{"name":"../utils/bv-event.class","loc":{"line":15,"column":24,"index":1815},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/bv-event.class.js"},{"name":"../utils/dom","loc":{"line":16,"column":81,"index":1923},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/dom.js"},{"name":"../utils/events","loc":{"line":17,"column":44,"index":1983},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/events.js"},{"name":"../utils/inspect","loc":{"line":18,"column":23,"index":2025},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/inspect.js"},{"name":"../utils/object","loc":{"line":19,"column":36,"index":2081},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/object.js"},{"name":"../utils/props","loc":{"line":20,"column":48,"index":2148},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js"},{"name":"../utils/warn","loc":{"line":21,"column":21,"index":2187},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/warn.js"},{"name":"./click-out","loc":{"line":22,"column":30,"index":2234},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/click-out.js"},{"name":"./focus-in","loc":{"line":23,"column":29,"index":2278},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/focus-in.js"},{"name":"./id","loc":{"line":24,"column":42,"index":2334},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/id.js"},{"name":"./listen-on-root","loc":{"line":25,"column":34,"index":2376},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/dropdown.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/listen-on-root.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.props = exports.dropdownMixin = void 0;\n\nvar _popper = _interopRequireDefault(require(\"popper.js\"));\n\nvar _vue = require(\"../vue\");\n\nvar _components = require(\"../constants/components\");\n\nvar _events = require(\"../constants/events\");\n\nvar _keyCodes = require(\"../constants/key-codes\");\n\nvar _popper2 = require(\"../constants/popper\");\n\nvar _props = require(\"../constants/props\");\n\nvar _safeTypes = require(\"../constants/safe-types\");\n\nvar _bvEvent = require(\"../utils/bv-event.class\");\n\nvar _dom = require(\"../utils/dom\");\n\nvar _events2 = require(\"../utils/events\");\n\nvar _inspect = require(\"../utils/inspect\");\n\nvar _object = require(\"../utils/object\");\n\nvar _props2 = require(\"../utils/props\");\n\nvar _warn = require(\"../utils/warn\");\n\nvar _clickOut = require(\"./click-out\");\n\nvar _focusIn = require(\"./focus-in\");\n\nvar _id = require(\"./id\");\n\nvar _listenOnRoot = require(\"./listen-on-root\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n// --- Constants ---\nvar ROOT_EVENT_NAME_SHOWN = (0, _events2.getRootEventName)(_components.NAME_DROPDOWN, _events.EVENT_NAME_SHOWN);\nvar ROOT_EVENT_NAME_HIDDEN = (0, _events2.getRootEventName)(_components.NAME_DROPDOWN, _events.EVENT_NAME_HIDDEN); // CSS selectors\n\nvar SELECTOR_FORM_CHILD = '.dropdown form';\nvar SELECTOR_ITEM = ['.dropdown-item', '.b-dropdown-form'].map(function (selector) {\n  return \"\".concat(selector, \":not(.disabled):not([disabled])\");\n}).join(', '); // --- Helper methods ---\n// Return an array of visible items\n\nvar filterVisibles = function filterVisibles(els) {\n  return (els || []).filter(_dom.isVisible);\n}; // --- Props ---\n\n\nvar props = (0, _props2.makePropsConfigurable)((0, _object.sortKeys)(_objectSpread(_objectSpread({}, _id.props), {}, {\n  // String: `scrollParent`, `window` or `viewport`\n  // HTMLElement: HTML Element reference\n  boundary: (0, _props2.makeProp)([_safeTypes.HTMLElement, _props.PROP_TYPE_STRING], 'scrollParent'),\n  disabled: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // Place left if possible\n  dropleft: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // Place right if possible\n  dropright: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // Place on top if possible\n  dropup: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // Disable auto-flipping of menu from bottom <=> top\n  noFlip: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  // Number of pixels or a CSS unit value to offset menu\n  // (i.e. `1px`, `1rem`, etc.)\n  offset: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING, 0),\n  popperOpts: (0, _props2.makeProp)(_props.PROP_TYPE_OBJECT, {}),\n  // Right align menu (default is left align)\n  right: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false)\n})), _components.NAME_DROPDOWN); // --- Mixin ---\n// @vue/component\n\nexports.props = props;\n\nvar dropdownMixin = _vue.Vue.extend({\n  mixins: [_id.idMixin, _listenOnRoot.listenOnRootMixin, _clickOut.clickOutMixin, _focusIn.focusInMixin],\n  provide: function provide() {\n    return {\n      bvDropdown: this\n    };\n  },\n  inject: {\n    bvNavbar: {\n      default: null\n    }\n  },\n  props: props,\n  data: function data() {\n    return {\n      visible: false,\n      visibleChangePrevented: false\n    };\n  },\n  computed: {\n    inNavbar: function inNavbar() {\n      return !(0, _inspect.isNull)(this.bvNavbar);\n    },\n    toggler: function toggler() {\n      var toggle = this.$refs.toggle;\n      return toggle ? toggle.$el || toggle : null;\n    },\n    directionClass: function directionClass() {\n      if (this.dropup) {\n        return 'dropup';\n      } else if (this.dropright) {\n        return 'dropright';\n      } else if (this.dropleft) {\n        return 'dropleft';\n      }\n\n      return '';\n    },\n    boundaryClass: function boundaryClass() {\n      // Position `static` is needed to allow menu to \"breakout\" of the `scrollParent`\n      // boundaries when boundary is anything other than `scrollParent`\n      // See: https://github.com/twbs/bootstrap/issues/24251#issuecomment-341413786\n      return this.boundary !== 'scrollParent' && !this.inNavbar ? 'position-static' : '';\n    }\n  },\n  watch: {\n    visible: function visible(newValue, oldValue) {\n      if (this.visibleChangePrevented) {\n        this.visibleChangePrevented = false;\n        return;\n      }\n\n      if (newValue !== oldValue) {\n        var eventName = newValue ? _events.EVENT_NAME_SHOW : _events.EVENT_NAME_HIDE;\n        var bvEvent = new _bvEvent.BvEvent(eventName, {\n          cancelable: true,\n          vueTarget: this,\n          target: this.$refs.menu,\n          relatedTarget: null,\n          componentId: this.safeId ? this.safeId() : this.id || null\n        });\n        this.emitEvent(bvEvent);\n\n        if (bvEvent.defaultPrevented) {\n          // Reset value and exit if canceled\n          this.visibleChangePrevented = true;\n          this.visible = oldValue; // Just in case a child element triggered `this.hide(true)`\n\n          this.$off(_events.EVENT_NAME_HIDDEN, this.focusToggler);\n          return;\n        }\n\n        if (newValue) {\n          this.showMenu();\n        } else {\n          this.hideMenu();\n        }\n      }\n    },\n    disabled: function disabled(newValue, oldValue) {\n      if (newValue !== oldValue && newValue && this.visible) {\n        // Hide dropdown if disabled changes to true\n        this.visible = false;\n      }\n    }\n  },\n  created: function created() {\n    // Create private non-reactive props\n    this.$_popper = null;\n    this.$_hideTimeout = null;\n  },\n\n  /* istanbul ignore next */\n  deactivated: function deactivated() {\n    // In case we are inside a `<keep-alive>`\n    this.visible = false;\n    this.whileOpenListen(false);\n    this.destroyPopper();\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.visible = false;\n    this.whileOpenListen(false);\n    this.destroyPopper();\n    this.clearHideTimeout();\n  },\n  methods: {\n    // Event emitter\n    emitEvent: function emitEvent(bvEvent) {\n      var type = bvEvent.type;\n      this.emitOnRoot((0, _events2.getRootEventName)(_components.NAME_DROPDOWN, type), bvEvent);\n      this.$emit(type, bvEvent);\n    },\n    showMenu: function showMenu() {\n      var _this = this;\n\n      if (this.disabled) {\n        /* istanbul ignore next */\n        return;\n      } // Only instantiate Popper.js when dropdown is not in `<b-navbar>`\n\n\n      if (!this.inNavbar) {\n        if (typeof _popper.default === 'undefined') {\n          /* istanbul ignore next */\n          (0, _warn.warn)('Popper.js not found. Falling back to CSS positioning', _components.NAME_DROPDOWN);\n        } else {\n          // For dropup with alignment we use the parent element as popper container\n          var el = this.dropup && this.right || this.split ? this.$el : this.$refs.toggle; // Make sure we have a reference to an element, not a component!\n\n          el = el.$el || el; // Instantiate Popper.js\n\n          this.createPopper(el);\n        }\n      } // Ensure other menus are closed\n\n\n      this.emitOnRoot(ROOT_EVENT_NAME_SHOWN, this); // Enable listeners\n\n      this.whileOpenListen(true); // Wrap in `$nextTick()` to ensure menu is fully rendered/shown\n\n      this.$nextTick(function () {\n        // Focus on the menu container on show\n        _this.focusMenu(); // Emit the shown event\n\n\n        _this.$emit(_events.EVENT_NAME_SHOWN);\n      });\n    },\n    hideMenu: function hideMenu() {\n      this.whileOpenListen(false);\n      this.emitOnRoot(ROOT_EVENT_NAME_HIDDEN, this);\n      this.$emit(_events.EVENT_NAME_HIDDEN);\n      this.destroyPopper();\n    },\n    createPopper: function createPopper(element) {\n      this.destroyPopper();\n      this.$_popper = new _popper.default(element, this.$refs.menu, this.getPopperConfig());\n    },\n    // Ensure popper event listeners are removed cleanly\n    destroyPopper: function destroyPopper() {\n      this.$_popper && this.$_popper.destroy();\n      this.$_popper = null;\n    },\n    // Instructs popper to re-computes the dropdown position\n    // useful if the content changes size\n    updatePopper: function updatePopper() {\n      try {\n        this.$_popper.scheduleUpdate();\n      } catch (_unused) {}\n    },\n    clearHideTimeout: function clearHideTimeout() {\n      clearTimeout(this.$_hideTimeout);\n      this.$_hideTimeout = null;\n    },\n    getPopperConfig: function getPopperConfig() {\n      var placement = _popper2.PLACEMENT_BOTTOM_START;\n\n      if (this.dropup) {\n        placement = this.right ? _popper2.PLACEMENT_TOP_END : _popper2.PLACEMENT_TOP_START;\n      } else if (this.dropright) {\n        placement = _popper2.PLACEMENT_RIGHT_START;\n      } else if (this.dropleft) {\n        placement = _popper2.PLACEMENT_LEFT_START;\n      } else if (this.right) {\n        placement = _popper2.PLACEMENT_BOTTOM_END;\n      }\n\n      var popperConfig = {\n        placement: placement,\n        modifiers: {\n          offset: {\n            offset: this.offset || 0\n          },\n          flip: {\n            enabled: !this.noFlip\n          }\n        }\n      };\n      var boundariesElement = this.boundary;\n\n      if (boundariesElement) {\n        popperConfig.modifiers.preventOverflow = {\n          boundariesElement: boundariesElement\n        };\n      }\n\n      return (0, _object.mergeDeep)(popperConfig, this.popperOpts || {});\n    },\n    // Turn listeners on/off while open\n    whileOpenListen: function whileOpenListen(isOpen) {\n      // Hide the dropdown when clicked outside\n      this.listenForClickOut = isOpen; // Hide the dropdown when it loses focus\n\n      this.listenForFocusIn = isOpen; // Hide the dropdown when another dropdown is opened\n\n      var method = isOpen ? '$on' : '$off';\n      this.$root[method](ROOT_EVENT_NAME_SHOWN, this.rootCloseListener);\n    },\n    rootCloseListener: function rootCloseListener(vm) {\n      if (vm !== this) {\n        this.visible = false;\n      }\n    },\n    // Public method to show dropdown\n    show: function show() {\n      var _this2 = this;\n\n      if (this.disabled) {\n        return;\n      } // Wrap in a `requestAF()` to allow any previous\n      // click handling to occur first\n\n\n      (0, _dom.requestAF)(function () {\n        _this2.visible = true;\n      });\n    },\n    // Public method to hide dropdown\n    hide: function hide() {\n      var refocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      /* istanbul ignore next */\n\n      if (this.disabled) {\n        return;\n      }\n\n      this.visible = false;\n\n      if (refocus) {\n        // Child element is closing the dropdown on click\n        this.$once(_events.EVENT_NAME_HIDDEN, this.focusToggler);\n      }\n    },\n    // Called only by a button that toggles the menu\n    toggle: function toggle(event) {\n      event = event || {}; // Early exit when not a click event or ENTER, SPACE or DOWN were pressed\n\n      var _event = event,\n          type = _event.type,\n          keyCode = _event.keyCode;\n\n      if (type !== 'click' && !(type === 'keydown' && [_keyCodes.CODE_ENTER, _keyCodes.CODE_SPACE, _keyCodes.CODE_DOWN].indexOf(keyCode) !== -1)) {\n        /* istanbul ignore next */\n        return;\n      }\n      /* istanbul ignore next */\n\n\n      if (this.disabled) {\n        this.visible = false;\n        return;\n      }\n\n      this.$emit(_events.EVENT_NAME_TOGGLE, event);\n      (0, _events2.stopEvent)(event); // Toggle visibility\n\n      if (this.visible) {\n        this.hide(true);\n      } else {\n        this.show();\n      }\n    },\n    // Mousedown handler for the toggle\n\n    /* istanbul ignore next */\n    onMousedown: function onMousedown(event) {\n      // We prevent the 'mousedown' event for the toggle to stop the\n      // 'focusin' event from being fired\n      // The event would otherwise be picked up by the global 'focusin'\n      // listener and there is no cross-browser solution to detect it\n      // relates to the toggle click\n      // The 'click' event will still be fired and we handle closing\n      // other dropdowns there too\n      // See https://github.com/bootstrap-vue/bootstrap-vue/issues/4328\n      (0, _events2.stopEvent)(event, {\n        propagation: false\n      });\n    },\n    // Called from dropdown menu context\n    onKeydown: function onKeydown(event) {\n      var keyCode = event.keyCode;\n\n      if (keyCode === _keyCodes.CODE_ESC) {\n        // Close on ESC\n        this.onEsc(event);\n      } else if (keyCode === _keyCodes.CODE_DOWN) {\n        // Down Arrow\n        this.focusNext(event, false);\n      } else if (keyCode === _keyCodes.CODE_UP) {\n        // Up Arrow\n        this.focusNext(event, true);\n      }\n    },\n    // If user presses ESC, close the menu\n    onEsc: function onEsc(event) {\n      if (this.visible) {\n        this.visible = false;\n        (0, _events2.stopEvent)(event); // Return focus to original trigger button\n\n        this.$once(_events.EVENT_NAME_HIDDEN, this.focusToggler);\n      }\n    },\n    // Called only in split button mode, for the split button\n    onSplitClick: function onSplitClick(event) {\n      /* istanbul ignore next */\n      if (this.disabled) {\n        this.visible = false;\n        return;\n      }\n\n      this.$emit(_events.EVENT_NAME_CLICK, event);\n    },\n    // Shared hide handler between click-out and focus-in events\n    hideHandler: function hideHandler(event) {\n      var _this3 = this;\n\n      var target = event.target;\n\n      if (this.visible && !(0, _dom.contains)(this.$refs.menu, target) && !(0, _dom.contains)(this.toggler, target)) {\n        this.clearHideTimeout();\n        this.$_hideTimeout = setTimeout(function () {\n          return _this3.hide();\n        }, this.inNavbar ? 300 : 0);\n      }\n    },\n    // Document click-out listener\n    clickOutHandler: function clickOutHandler(event) {\n      this.hideHandler(event);\n    },\n    // Document focus-in listener\n    focusInHandler: function focusInHandler(event) {\n      this.hideHandler(event);\n    },\n    // Keyboard nav\n    focusNext: function focusNext(event, up) {\n      var _this4 = this; // Ignore key up/down on form elements\n\n\n      var target = event.target;\n\n      if (!this.visible || event && (0, _dom.closest)(SELECTOR_FORM_CHILD, target)) {\n        /* istanbul ignore next: should never happen */\n        return;\n      }\n\n      (0, _events2.stopEvent)(event);\n      this.$nextTick(function () {\n        var items = _this4.getItems();\n\n        if (items.length < 1) {\n          /* istanbul ignore next: should never happen */\n          return;\n        }\n\n        var index = items.indexOf(target);\n\n        if (up && index > 0) {\n          index--;\n        } else if (!up && index < items.length - 1) {\n          index++;\n        }\n\n        if (index < 0) {\n          /* istanbul ignore next: should never happen */\n          index = 0;\n        }\n\n        _this4.focusItem(index, items);\n      });\n    },\n    focusItem: function focusItem(index, items) {\n      var el = items.find(function (el, i) {\n        return i === index;\n      });\n      (0, _dom.attemptFocus)(el);\n    },\n    getItems: function getItems() {\n      // Get all items\n      return filterVisibles((0, _dom.selectAll)(SELECTOR_ITEM, this.$refs.menu));\n    },\n    focusMenu: function focusMenu() {\n      (0, _dom.attemptFocus)(this.$refs.menu);\n    },\n    focusToggler: function focusToggler() {\n      var _this5 = this;\n\n      this.$nextTick(function () {\n        (0, _dom.attemptFocus)(_this5.toggler);\n      });\n    }\n  }\n});\n\nexports.dropdownMixin = dropdownMixin;"},"sourceMaps":null,"error":null,"hash":"e3477d2bdc96e5ab5fe6b665ebaf676a","cacheData":{"env":{}}}