{"id":"../node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","dependencies":[{"name":"/data/uibuilder/navbar/package.json","includedInParent":true,"mtime":1654946937447},{"name":"/data/uibuilder/navbar/node_modules/bootstrap-vue/package.json","includedInParent":true,"mtime":1651564048996},{"name":"../../vue","loc":{"line":9,"column":20,"index":1123},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/vue.js"},{"name":"../../constants/components","loc":{"line":10,"column":37,"index":1173},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/components.js"},{"name":"../../constants/events","loc":{"line":11,"column":34,"index":1237},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/events.js"},{"name":"../../constants/props","loc":{"line":12,"column":147,"index":1410},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/props.js"},{"name":"../../constants/key-codes","loc":{"line":13,"column":84,"index":1519},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/key-codes.js"},{"name":"../../constants/slots","loc":{"line":14,"column":57,"index":1605},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/constants/slots.js"},{"name":"../../utils/array","loc":{"line":15,"column":38,"index":1668},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/array.js"},{"name":"../../utils/dom","loc":{"line":16,"column":42,"index":1731},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/dom.js"},{"name":"../../utils/events","loc":{"line":17,"column":38,"index":1788},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/events.js"},{"name":"../../utils/identity","loc":{"line":18,"column":25,"index":1835},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/identity.js"},{"name":"../../utils/inspect","loc":{"line":19,"column":23,"index":1882},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/inspect.js"},{"name":"../../utils/locale","loc":{"line":20,"column":28,"index":1933},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/locale.js"},{"name":"../../utils/math","loc":{"line":21,"column":55,"index":2010},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/math.js"},{"name":"../../utils/model","loc":{"line":22,"column":31,"index":2061},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/model.js"},{"name":"../../utils/number","loc":{"line":23,"column":35,"index":2117},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/number.js"},{"name":"../../utils/object","loc":{"line":24,"column":31,"index":2170},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/object.js"},{"name":"../../utils/props","loc":{"line":25,"column":65,"index":2257},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/props.js"},{"name":"../../utils/string","loc":{"line":26,"column":25,"index":2303},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/utils/string.js"},{"name":"../../mixins/attrs","loc":{"line":27,"column":27,"index":2352},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/attrs.js"},{"name":"../../mixins/form-size","loc":{"line":28,"column":54,"index":2428},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-size.js"},{"name":"../../mixins/form-state","loc":{"line":29,"column":56,"index":2510},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-state.js"},{"name":"../../mixins/id","loc":{"line":30,"column":42,"index":2579},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/id.js"},{"name":"../../mixins/normalize-slot","loc":{"line":31,"column":35,"index":2633},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/normalize-slot.js"},{"name":"../../mixins/form-control","loc":{"line":32,"column":42,"index":2706},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/mixins/form-control.js"},{"name":"../../icons/icons","loc":{"line":33,"column":37,"index":2772},"parent":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/components/form-spinbutton/form-spinbutton.js","resolved":"/data/uibuilder/navbar/node_modules/bootstrap-vue/esm/icons/icons.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.props = exports.BFormSpinbutton = void 0;\n\nvar _vue = require(\"../../vue\");\n\nvar _components = require(\"../../constants/components\");\n\nvar _events = require(\"../../constants/events\");\n\nvar _props = require(\"../../constants/props\");\n\nvar _keyCodes = require(\"../../constants/key-codes\");\n\nvar _slots = require(\"../../constants/slots\");\n\nvar _array = require(\"../../utils/array\");\n\nvar _dom = require(\"../../utils/dom\");\n\nvar _events2 = require(\"../../utils/events\");\n\nvar _identity = require(\"../../utils/identity\");\n\nvar _inspect = require(\"../../utils/inspect\");\n\nvar _locale = require(\"../../utils/locale\");\n\nvar _math = require(\"../../utils/math\");\n\nvar _model = require(\"../../utils/model\");\n\nvar _number = require(\"../../utils/number\");\n\nvar _object = require(\"../../utils/object\");\n\nvar _props2 = require(\"../../utils/props\");\n\nvar _string = require(\"../../utils/string\");\n\nvar _attrs = require(\"../../mixins/attrs\");\n\nvar _formSize = require(\"../../mixins/form-size\");\n\nvar _formState = require(\"../../mixins/form-state\");\n\nvar _id = require(\"../../mixins/id\");\n\nvar _normalizeSlot = require(\"../../mixins/normalize-slot\");\n\nvar _formControl = require(\"../../mixins/form-control\");\n\nvar _icons = require(\"../../icons/icons\");\n\nvar _watch;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n// --- Constants ---\nvar _makeModelMixin = (0, _model.makeModelMixin)('value', {\n  // Should this really be String, to match native number inputs?\n  type: _props.PROP_TYPE_BOOLEAN_NUMBER\n}),\n    modelMixin = _makeModelMixin.mixin,\n    modelProps = _makeModelMixin.props,\n    MODEL_PROP_NAME = _makeModelMixin.prop,\n    MODEL_EVENT_NAME = _makeModelMixin.event; // Default for spin button range and step\n\n\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 100;\nvar DEFAULT_STEP = 1; // Delay before auto-repeat in ms\n\nvar DEFAULT_REPEAT_DELAY = 500; // Repeat interval in ms\n\nvar DEFAULT_REPEAT_INTERVAL = 100; // Repeat rate increased after number of repeats\n\nvar DEFAULT_REPEAT_THRESHOLD = 10; // Repeat speed multiplier (step multiplier, must be an integer)\n\nvar DEFAULT_REPEAT_MULTIPLIER = 4;\nvar KEY_CODES = [_keyCodes.CODE_UP, _keyCodes.CODE_DOWN, _keyCodes.CODE_HOME, _keyCodes.CODE_END, _keyCodes.CODE_PAGEUP, _keyCodes.CODE_PAGEDOWN]; // --- Props ---\n\nvar props = (0, _props2.makePropsConfigurable)((0, _object.sortKeys)(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, _id.props), modelProps), (0, _object.omit)(_formControl.props, ['required', 'autofocus'])), _formSize.props), _formState.props), {}, {\n  ariaControls: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n  ariaLabel: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n  formatterFn: (0, _props2.makeProp)(_props.PROP_TYPE_FUNCTION),\n  inline: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  labelDecrement: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Decrement'),\n  labelIncrement: (0, _props2.makeProp)(_props.PROP_TYPE_STRING, 'Increment'),\n  locale: (0, _props2.makeProp)(_props.PROP_TYPE_ARRAY_STRING),\n  max: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING, DEFAULT_MAX),\n  min: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING, DEFAULT_MIN),\n  placeholder: (0, _props2.makeProp)(_props.PROP_TYPE_STRING),\n  readonly: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  repeatDelay: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING, DEFAULT_REPEAT_DELAY),\n  repeatInterval: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING, DEFAULT_REPEAT_INTERVAL),\n  repeatStepMultiplier: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING, DEFAULT_REPEAT_MULTIPLIER),\n  repeatThreshold: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING, DEFAULT_REPEAT_THRESHOLD),\n  step: (0, _props2.makeProp)(_props.PROP_TYPE_NUMBER_STRING, DEFAULT_STEP),\n  vertical: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false),\n  wrap: (0, _props2.makeProp)(_props.PROP_TYPE_BOOLEAN, false)\n})), _components.NAME_FORM_SPINBUTTON); // --- Main Component ---\n// @vue/component\n\nexports.props = props;\n\nvar BFormSpinbutton = /*#__PURE__*/_vue.Vue.extend({\n  name: _components.NAME_FORM_SPINBUTTON,\n  // Mixin order is important!\n  mixins: [_attrs.attrsMixin, _id.idMixin, modelMixin, _formSize.formSizeMixin, _formState.formStateMixin, _normalizeSlot.normalizeSlotMixin],\n  inheritAttrs: false,\n  props: props,\n  data: function data() {\n    return {\n      localValue: (0, _number.toFloat)(this[MODEL_PROP_NAME], null),\n      hasFocus: false\n    };\n  },\n  computed: {\n    spinId: function spinId() {\n      return this.safeId();\n    },\n    computedInline: function computedInline() {\n      return this.inline && !this.vertical;\n    },\n    computedReadonly: function computedReadonly() {\n      return this.readonly && !this.disabled;\n    },\n    computedRequired: function computedRequired() {\n      return this.required && !this.computedReadonly && !this.disabled;\n    },\n    computedStep: function computedStep() {\n      return (0, _number.toFloat)(this.step, DEFAULT_STEP);\n    },\n    computedMin: function computedMin() {\n      return (0, _number.toFloat)(this.min, DEFAULT_MIN);\n    },\n    computedMax: function computedMax() {\n      // We round down to the nearest maximum step value\n      var max = (0, _number.toFloat)(this.max, DEFAULT_MAX);\n      var step = this.computedStep;\n      var min = this.computedMin;\n      return (0, _math.mathFloor)((max - min) / step) * step + min;\n    },\n    computedDelay: function computedDelay() {\n      var delay = (0, _number.toInteger)(this.repeatDelay, 0);\n      return delay > 0 ? delay : DEFAULT_REPEAT_DELAY;\n    },\n    computedInterval: function computedInterval() {\n      var interval = (0, _number.toInteger)(this.repeatInterval, 0);\n      return interval > 0 ? interval : DEFAULT_REPEAT_INTERVAL;\n    },\n    computedThreshold: function computedThreshold() {\n      return (0, _math.mathMax)((0, _number.toInteger)(this.repeatThreshold, DEFAULT_REPEAT_THRESHOLD), 1);\n    },\n    computedStepMultiplier: function computedStepMultiplier() {\n      return (0, _math.mathMax)((0, _number.toInteger)(this.repeatStepMultiplier, DEFAULT_REPEAT_MULTIPLIER), 1);\n    },\n    computedPrecision: function computedPrecision() {\n      // Quick and dirty way to get the number of decimals\n      var step = this.computedStep;\n      return (0, _math.mathFloor)(step) === step ? 0 : (step.toString().split('.')[1] || '').length;\n    },\n    computedMultiplier: function computedMultiplier() {\n      return (0, _math.mathPow)(10, this.computedPrecision || 0);\n    },\n    valueAsFixed: function valueAsFixed() {\n      var value = this.localValue;\n      return (0, _inspect.isNull)(value) ? '' : value.toFixed(this.computedPrecision);\n    },\n    computedLocale: function computedLocale() {\n      var locales = (0, _array.concat)(this.locale).filter(_identity.identity);\n      var nf = new Intl.NumberFormat(locales);\n      return nf.resolvedOptions().locale;\n    },\n    computedRTL: function computedRTL() {\n      return (0, _locale.isLocaleRTL)(this.computedLocale);\n    },\n    defaultFormatter: function defaultFormatter() {\n      // Returns and `Intl.NumberFormat` formatter method reference\n      var precision = this.computedPrecision;\n      var nf = new Intl.NumberFormat(this.computedLocale, {\n        style: 'decimal',\n        useGrouping: false,\n        minimumIntegerDigits: 1,\n        minimumFractionDigits: precision,\n        maximumFractionDigits: precision,\n        notation: 'standard'\n      }); // Return the format method reference\n\n      return nf.format;\n    },\n    computedFormatter: function computedFormatter() {\n      var formatterFn = this.formatterFn;\n      return (0, _props2.hasPropFunction)(formatterFn) ? formatterFn : this.defaultFormatter;\n    },\n    computedAttrs: function computedAttrs() {\n      return _objectSpread(_objectSpread({}, this.bvAttrs), {}, {\n        role: 'group',\n        lang: this.computedLocale,\n        tabindex: this.disabled ? null : '-1',\n        title: this.ariaLabel\n      });\n    },\n    computedSpinAttrs: function computedSpinAttrs() {\n      var spinId = this.spinId,\n          value = this.localValue,\n          required = this.computedRequired,\n          disabled = this.disabled,\n          state = this.state,\n          computedFormatter = this.computedFormatter;\n      var hasValue = !(0, _inspect.isNull)(value);\n      return _objectSpread(_objectSpread({\n        dir: this.computedRTL ? 'rtl' : 'ltr'\n      }, this.bvAttrs), {}, {\n        id: spinId,\n        role: 'spinbutton',\n        tabindex: disabled ? null : '0',\n        'aria-live': 'off',\n        'aria-label': this.ariaLabel || null,\n        'aria-controls': this.ariaControls || null,\n        // TODO: May want to check if the value is in range\n        'aria-invalid': state === false || !hasValue && required ? 'true' : null,\n        'aria-required': required ? 'true' : null,\n        // These attrs are required for role spinbutton\n        'aria-valuemin': (0, _string.toString)(this.computedMin),\n        'aria-valuemax': (0, _string.toString)(this.computedMax),\n        // These should be `null` if the value is out of range\n        // They must also be non-existent attrs if the value is out of range or `null`\n        'aria-valuenow': hasValue ? value : null,\n        'aria-valuetext': hasValue ? computedFormatter(value) : null\n      });\n    }\n  },\n  watch: (_watch = {}, _defineProperty(_watch, MODEL_PROP_NAME, function (value) {\n    this.localValue = (0, _number.toFloat)(value, null);\n  }), _defineProperty(_watch, \"localValue\", function localValue(value) {\n    this.$emit(MODEL_EVENT_NAME, value);\n  }), _defineProperty(_watch, \"disabled\", function disabled(_disabled) {\n    if (_disabled) {\n      this.clearRepeat();\n    }\n  }), _defineProperty(_watch, \"readonly\", function readonly(_readonly) {\n    if (_readonly) {\n      this.clearRepeat();\n    }\n  }), _watch),\n  created: function created() {\n    // Create non reactive properties\n    this.$_autoDelayTimer = null;\n    this.$_autoRepeatTimer = null;\n    this.$_keyIsDown = false;\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.clearRepeat();\n  },\n\n  /* istanbul ignore next */\n  deactivated: function deactivated() {\n    this.clearRepeat();\n  },\n  methods: {\n    // --- Public methods ---\n    focus: function focus() {\n      if (!this.disabled) {\n        (0, _dom.attemptFocus)(this.$refs.spinner);\n      }\n    },\n    blur: function blur() {\n      if (!this.disabled) {\n        (0, _dom.attemptBlur)(this.$refs.spinner);\n      }\n    },\n    // --- Private methods ---\n    emitChange: function emitChange() {\n      this.$emit(_events.EVENT_NAME_CHANGE, this.localValue);\n    },\n    stepValue: function stepValue(direction) {\n      // Sets a new incremented or decremented value, supporting optional wrapping\n      // Direction is either +1 or -1 (or a multiple thereof)\n      var value = this.localValue;\n\n      if (!this.disabled && !(0, _inspect.isNull)(value)) {\n        var step = this.computedStep * direction;\n        var min = this.computedMin;\n        var max = this.computedMax;\n        var multiplier = this.computedMultiplier;\n        var wrap = this.wrap; // We ensure that the value steps like a native input\n\n        value = (0, _math.mathRound)((value - min) / step) * step + min + step; // We ensure that precision is maintained (decimals)\n\n        value = (0, _math.mathRound)(value * multiplier) / multiplier; // Handle if wrapping is enabled\n\n        this.localValue = value > max ? wrap ? min : max : value < min ? wrap ? max : min : value;\n      }\n    },\n    onFocusBlur: function onFocusBlur(event) {\n      if (!this.disabled) {\n        this.hasFocus = event.type === 'focus';\n      } else {\n        this.hasFocus = false;\n      }\n    },\n    stepUp: function stepUp() {\n      var multiplier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var value = this.localValue;\n\n      if ((0, _inspect.isNull)(value)) {\n        this.localValue = this.computedMin;\n      } else {\n        this.stepValue(+1 * multiplier);\n      }\n    },\n    stepDown: function stepDown() {\n      var multiplier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var value = this.localValue;\n\n      if ((0, _inspect.isNull)(value)) {\n        this.localValue = this.wrap ? this.computedMax : this.computedMin;\n      } else {\n        this.stepValue(-1 * multiplier);\n      }\n    },\n    onKeydown: function onKeydown(event) {\n      var keyCode = event.keyCode,\n          altKey = event.altKey,\n          ctrlKey = event.ctrlKey,\n          metaKey = event.metaKey;\n      /* istanbul ignore if */\n\n      if (this.disabled || this.readonly || altKey || ctrlKey || metaKey) {\n        return;\n      }\n\n      if ((0, _array.arrayIncludes)(KEY_CODES, keyCode)) {\n        // https://w3c.github.io/aria-practices/#spinbutton\n        (0, _events2.stopEvent)(event, {\n          propagation: false\n        });\n        /* istanbul ignore if */\n\n        if (this.$_keyIsDown) {\n          // Keypress is already in progress\n          return;\n        }\n\n        this.resetTimers();\n\n        if ((0, _array.arrayIncludes)([_keyCodes.CODE_UP, _keyCodes.CODE_DOWN], keyCode)) {\n          // The following use the custom auto-repeat handling\n          this.$_keyIsDown = true;\n\n          if (keyCode === _keyCodes.CODE_UP) {\n            this.handleStepRepeat(event, this.stepUp);\n          } else if (keyCode === _keyCodes.CODE_DOWN) {\n            this.handleStepRepeat(event, this.stepDown);\n          }\n        } else {\n          // These use native OS key repeating\n          if (keyCode === _keyCodes.CODE_PAGEUP) {\n            this.stepUp(this.computedStepMultiplier);\n          } else if (keyCode === _keyCodes.CODE_PAGEDOWN) {\n            this.stepDown(this.computedStepMultiplier);\n          } else if (keyCode === _keyCodes.CODE_HOME) {\n            this.localValue = this.computedMin;\n          } else if (keyCode === _keyCodes.CODE_END) {\n            this.localValue = this.computedMax;\n          }\n        }\n      }\n    },\n    onKeyup: function onKeyup(event) {\n      // Emit a change event when the keyup happens\n      var keyCode = event.keyCode,\n          altKey = event.altKey,\n          ctrlKey = event.ctrlKey,\n          metaKey = event.metaKey;\n      /* istanbul ignore if */\n\n      if (this.disabled || this.readonly || altKey || ctrlKey || metaKey) {\n        return;\n      }\n\n      if ((0, _array.arrayIncludes)(KEY_CODES, keyCode)) {\n        (0, _events2.stopEvent)(event, {\n          propagation: false\n        });\n        this.resetTimers();\n        this.$_keyIsDown = false;\n        this.emitChange();\n      }\n    },\n    handleStepRepeat: function handleStepRepeat(event, stepper) {\n      var _this = this;\n\n      var _ref = event || {},\n          type = _ref.type,\n          button = _ref.button;\n\n      if (!this.disabled && !this.readonly) {\n        /* istanbul ignore if */\n        if (type === 'mousedown' && button) {\n          // We only respond to left (main === 0) button clicks\n          return;\n        }\n\n        this.resetTimers(); // Step the counter initially\n\n        stepper(1);\n        var threshold = this.computedThreshold;\n        var multiplier = this.computedStepMultiplier;\n        var delay = this.computedDelay;\n        var interval = this.computedInterval; // Initiate the delay/repeat interval\n\n        this.$_autoDelayTimer = setTimeout(function () {\n          var count = 0;\n          _this.$_autoRepeatTimer = setInterval(function () {\n            // After N initial repeats, we increase the incrementing step amount\n            // We do this to minimize screen reader announcements of the value\n            // (values are announced every change, which can be chatty for SR users)\n            // And to make it easer to select a value when the range is large\n            stepper(count < threshold ? 1 : multiplier);\n            count++;\n          }, interval);\n        }, delay);\n      }\n    },\n    onMouseup: function onMouseup(event) {\n      // `<body>` listener, only enabled when mousedown starts\n      var _ref2 = event || {},\n          type = _ref2.type,\n          button = _ref2.button;\n      /* istanbul ignore if */\n\n\n      if (type === 'mouseup' && button) {\n        // Ignore non left button (main === 0) mouse button click\n        return;\n      }\n\n      (0, _events2.stopEvent)(event, {\n        propagation: false\n      });\n      this.resetTimers();\n      this.setMouseup(false); // Trigger the change event\n\n      this.emitChange();\n    },\n    setMouseup: function setMouseup(on) {\n      // Enable or disabled the body mouseup/touchend handlers\n      // Use try/catch to handle case when called server side\n      try {\n        (0, _events2.eventOnOff)(on, document.body, 'mouseup', this.onMouseup, false);\n        (0, _events2.eventOnOff)(on, document.body, 'touchend', this.onMouseup, false);\n      } catch (_unused) {}\n    },\n    resetTimers: function resetTimers() {\n      clearTimeout(this.$_autoDelayTimer);\n      clearInterval(this.$_autoRepeatTimer);\n      this.$_autoDelayTimer = null;\n      this.$_autoRepeatTimer = null;\n    },\n    clearRepeat: function clearRepeat() {\n      this.resetTimers();\n      this.setMouseup(false);\n      this.$_keyIsDown = false;\n    }\n  },\n  render: function render(h) {\n    var _this2 = this;\n\n    var spinId = this.spinId,\n        value = this.localValue,\n        inline = this.computedInline,\n        readonly = this.computedReadonly,\n        vertical = this.vertical,\n        disabled = this.disabled,\n        computedFormatter = this.computedFormatter;\n    var hasValue = !(0, _inspect.isNull)(value);\n\n    var makeButton = function makeButton(stepper, label, IconCmp, keyRef, shortcut, btnDisabled, slotName) {\n      var $icon = h(IconCmp, {\n        props: {\n          scale: _this2.hasFocus ? 1.5 : 1.25\n        },\n        attrs: {\n          'aria-hidden': 'true'\n        }\n      });\n      var scope = {\n        hasFocus: _this2.hasFocus\n      };\n\n      var handler = function handler(event) {\n        if (!disabled && !readonly) {\n          (0, _events2.stopEvent)(event, {\n            propagation: false\n          });\n\n          _this2.setMouseup(true); // Since we `preventDefault()`, we must manually focus the button\n\n\n          (0, _dom.attemptFocus)(event.currentTarget);\n\n          _this2.handleStepRepeat(event, stepper);\n        }\n      };\n\n      return h('button', {\n        staticClass: 'btn btn-sm border-0 rounded-0',\n        class: {\n          'py-0': !vertical\n        },\n        attrs: {\n          tabindex: '-1',\n          type: 'button',\n          disabled: disabled || readonly || btnDisabled,\n          'aria-disabled': disabled || readonly || btnDisabled ? 'true' : null,\n          'aria-controls': spinId,\n          'aria-label': label || null,\n          'aria-keyshortcuts': shortcut || null\n        },\n        on: {\n          mousedown: handler,\n          touchstart: handler\n        },\n        key: keyRef || null,\n        ref: keyRef\n      }, [_this2.normalizeSlot(slotName, scope) || $icon]);\n    }; // TODO: Add button disabled state when `wrap` is `false` and at value max/min\n\n\n    var $increment = makeButton(this.stepUp, this.labelIncrement, _icons.BIconPlus, 'inc', 'ArrowUp', false, _slots.SLOT_NAME_INCREMENT);\n    var $decrement = makeButton(this.stepDown, this.labelDecrement, _icons.BIconDash, 'dec', 'ArrowDown', false, _slots.SLOT_NAME_DECREMENT);\n    var $hidden = h();\n\n    if (this.name && !disabled) {\n      $hidden = h('input', {\n        attrs: {\n          type: 'hidden',\n          name: this.name,\n          form: this.form || null,\n          // TODO: Should this be set to '' if value is out of range?\n          value: this.valueAsFixed\n        },\n        key: 'hidden'\n      });\n    }\n\n    var $spin = h( // We use 'output' element to make this accept a `<label for=\"id\">` (Except IE)\n    'output', {\n      staticClass: 'flex-grow-1',\n      class: {\n        'd-flex': vertical,\n        'align-self-center': !vertical,\n        'align-items-center': vertical,\n        'border-top': vertical,\n        'border-bottom': vertical,\n        'border-left': !vertical,\n        'border-right': !vertical\n      },\n      attrs: this.computedSpinAttrs,\n      key: 'output',\n      ref: 'spinner'\n    }, [h('bdi', hasValue ? computedFormatter(value) : this.placeholder || '')]);\n    return h('div', {\n      staticClass: 'b-form-spinbutton form-control',\n      class: [{\n        disabled: disabled,\n        readonly: readonly,\n        focus: this.hasFocus,\n        'd-inline-flex': inline || vertical,\n        'd-flex': !inline && !vertical,\n        'align-items-stretch': !vertical,\n        'flex-column': vertical\n      }, this.sizeFormClass, this.stateClass],\n      attrs: this.computedAttrs,\n      on: {\n        keydown: this.onKeydown,\n        keyup: this.onKeyup,\n        // We use capture phase (`!` prefix) since focus and blur do not bubble\n        '!focus': this.onFocusBlur,\n        '!blur': this.onFocusBlur\n      }\n    }, vertical ? [$increment, $hidden, $spin, $decrement] : [$decrement, $hidden, $spin, $increment]);\n  }\n});\n\nexports.BFormSpinbutton = BFormSpinbutton;"},"sourceMaps":null,"error":null,"hash":"a74c897db547f1652006ce97e908f261","cacheData":{"env":{}}}